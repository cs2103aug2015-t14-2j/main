# A0097689
###### Task\COMMAND_TYPE.java
``` java
 */

public enum COMMAND_TYPE {
	PATH,
	FILEOPEN,
	FILESAVE,
	ADD_TASK, 
	GET_TASK,
	DISPLAY,
	EDIT_TASK, 
	DELETE_TASK,
	UNDO,
	REDO,
	INVALID_COMMAND, 
	DONE, 
	UNDONE,
	HELP,
	EXIT
}
```
###### Task\Context.java
``` java
 */

import Task.Pair;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Iterator;

import java.util.Locale;
import java.util.HashMap;
import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.io.OutputStreamWriter;
import java.io.Writer;

@SuppressWarnings("unused")
public class Context {
	private static Context context = null;
	
	// Variables for displaying on screen based on user input
	private static String FILEPATH;
	private static int    TASKID      = 0;
	private static String DEFAULT_DATE;

	// Define fullCalendar view options here, display on HTML template later to affect calendar view
	private static Pair   VIEW_DAY    = new Pair("agendaDay");
	private static Pair   VIEW_MONTH  = new Pair("month");
	private static Pair   VIEW_WEEK   = new Pair("agendaWeek");

	// Define success messages here
	private static Pair MESSAGE_WELCOME        = new Pair("Welcome to TaskBuddy!");
	private static Pair MESSAGE_PATH		   = new Pair("Your new path is: %s");
	private static Pair MESSAGE_SAVE		   = new Pair("Your calendar has been saved to %s!");
	private static Pair MESSAGE_OPEN		   = new Pair("Opening calendar at path %s");
	private static Pair MESSAGE_ADD_TASK       = new Pair("Successfully added task.");
	private static Pair MESSAGE_GET_TASK       = new Pair("Task %d returned");
	private static Pair MESSAGE_DISPLAY_ALL    = new Pair("All tasks displayed.");
	private static Pair MESSAGE_DISPLAY		   = new Pair("Search results:");
	private static Pair MESSAGE_SEARCH_TASK    = new Pair("Here are tasks matching your keywords:");
	private static Pair MESSAGE_DELETE_TASK    = new Pair("Task %d has been deleted");
	private static Pair MESSAGE_EDIT_TASK      = new Pair("Task %d has been updated!");
	private static Pair MESSAGE_UNDO_TASK      = new Pair("Successfully undoed change(s) to Task %d.");
	private static Pair MESSAGE_REDO_TASK      = new Pair("Successfully redoed change(s) to Task %d.");
	private static Pair MESSAGE_DONE_TASK      = new Pair("Successfully updated Task %d to completed.");
	private static Pair MESSAGE_UNDONE_TASK    = new Pair("Successfully updated Task %d to uncompleted.");
	private static Pair MESSAGE_EXIT           = new Pair("Thanks for using TaskBuddy! Changes saved to disk.");
	
	/** 
	 * Define warning messages here
	 * Warnings are less severe than errors.
	 * To communicate to the user they may have done something unintentional
	 */
	private static Pair WARNING_DEADLINE_BEFORE_NOW = new Pair("WARNING: You have specified a deadline that is before the current time");
	private static Pair WARNING_TASK_NOT_EDITED     = new Pair("Task %d was not edited.");

	// Define error messages here
	private static Pair ERROR_INVALID_COMMAND  = new Pair("Invalid Command.");
	private static Pair ERROR_EMPTY_TASKLIST   = new Pair("You have no tasks!");
	private static Pair ERROR_TASK_NOT_FOUND   = new Pair("The task was not found!");
	private static Pair ERROR_NO_RESUlTS_FOUND = new Pair("No results were found!");
	private static Pair ERROR_IO_TASK   	   = new Pair("The task could not be changed!");
	private static Pair ERROR_NO_DESC   	   = new Pair("You must have a description for your task!");
	private static Pair ERROR_CANNOT_UNDO      = new Pair("No more changes to undo.");
	private static Pair ERROR_CANNOT_REDO      = new Pair("No more changes to redo.");
	private static Pair ERROR_START_BEFORE_END = new Pair("You have entered an end time that is before start time!");
	private static Pair ERROR_DATEFORMAT       = new Pair("You have entered an invalid date and time. Note that we follow American date format mm/dd/yy.");
	private static Pair ERROR_TRIGGER_ERROR    = new Pair("ERROR! The trigger shortcut has been interrupted and aborted.");
	private static Pair ERROR_MALFORMED_TASK   = new Pair("ERROR! Corrupted task region. Task %d has been discarded.");
	private static Pair ERROR_MALFORMED_FILE   = new Pair("ERROR! Corrupted file region. Rest of file cannot be read.");
	private static Pair ERROR_MALFORMED_KEY    = new Pair("ERROR! File does not match expected format. Restart program with a new file location.");
	private static Pair ERROR_FILE_IO          = new Pair("ERROR! Cannot read from specified file location. Creating a new one.");
	private static Pair ERROR_HTML_TEMPLATE    = new Pair("ERROR! Cannot read html template.");
	
	// Define help messages here
	private static Pair HELP_TITLE             = new Pair("**********************************************************************Help menu for TaskBuddy!*****************************************************************");
	private static Pair HELP_HEADING           = new Pair("Please follow the following command format:");
	private static Pair HELP_SUBTITLE          = new Pair("[COMMAND]   [FORMAT]                                                                                                                                    ");
	private static Pair HELP_PATH              = new Pair("  PATH          : path [absolute filepath]");
	private static Pair HELP_FILEOPEN          = new Pair("  FILEOPEN  : fileopen");
	private static Pair HELP_FILESAVE          = new Pair("  FILESAVE   : filesave");
	private static Pair HELP_ADD_TASK          = new Pair("  ADD            : add do \"[description]\" on [startDate/endDate] from [startTime] to [endTime] by [deadlineDate] [deadlineTime] at \"[venue]\"              ");
	private static Pair HELP_DISPLAY           = new Pair("  DISPLAY    : display                                                                                                                                   ");
	private static Pair HELP_EDIT_TASK         = new Pair("  EDIT           : edit [task-id] do \"[description]\" on [startDate/endDate] from [startTime] to [endTime] by [deadlineDate] [deadlineTime] at \"[venue]\"      ");
	private static Pair HELP_UNDO              = new Pair("  UNDO        : undo                                                                                                                                      ");
	private static Pair HELP_REDO              = new Pair("  REDO        : redo                                                                                                                                      ");
	private static Pair HELP_DONE              = new Pair("  DONE        : done [task-id]                                                                                                                            ");
	private static Pair HELP_UNDONE            = new Pair("  UNDONE   : undone [task-id]                                                                                                                          ");	
	private static Pair HELP_DELETE_TASK       = new Pair("  DELETE     : delete [task-id]                                                                                                                          ");
	private static Pair HELP_HELP              = new Pair("  HELP         : help                                                                                                                                      ");
	private static Pair HELP_EXIT              = new Pair("  EXIT          : exit                                                                                                                                      ");
	
	// Define parameter specific messages here
	private static Pair PARAM_SUBTITLE      = new Pair("There are errors in the following parameters:");
	private static Pair PARAM_TASKID_NUM    = new Pair("TaskID          : Invalid number. Please enter a number greater than 0.");
	private static Pair PARAM_TASKID_NULL   = new Pair("TaskID          : Missing value. Please enter a number.");
	private static Pair PARAM_DESC          = new Pair("Description     : Invalid value. Please try again.");
	private static Pair PARAM_VENUE         = new Pair("Venue           : Invalid value. Please try again");
	private static Pair PARAM_START_DATE    = new Pair("Start Date      : Invalid date format.");
	private static Pair PARAM_END_DATE      = new Pair("End Date        : Invaild date format.");
	private static Pair PARAM_START_TIME    = new Pair("Start Time      : Invalid time format. Please be more specfic.");
	private static Pair PARAM_END_TIME      = new Pair("End Time        : Invalid time format. Please be more specific.");
	private static Pair PARAM_DEADLINE_DATE = new Pair("Deadline Date   : Invalid date format.");
	private static Pair PARAM_DEADLINE_TIME = new Pair("Deadline Time   : Invalid time format. Please be more specific.");

	// TaskList - set of tasks that will be displayed on the right panel
	private static ArrayList<Task> displayTaskSet = new ArrayList<Task>();
	
	private Context () {}
	
	// Singleton pattern, only one context object throughout application
	public static Context getInstance() {
		if (context==null) {
			context = new Context();
			return context;
		} else {
			return context;
		}
	}
	
	@SuppressWarnings("rawtypes")
	public void displayMessage(String fieldName) {
		Class thisClass = Context.class;
		
		try {
			Field field = thisClass.getDeclaredField(fieldName);
			field.setAccessible(true);
			Pair pair = (Pair) field.get(context);
			pair.displayMessage();

		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
	}

	@SuppressWarnings("rawtypes")
	public void clearMessage(String fieldName) {
		Class thisClass = Context.class;
		
		try {
			Field field = thisClass.getDeclaredField(fieldName);
			if (field.getType().isInstance(Pair.class)) {
				Object o = field.get(context);
				field.setAccessible(true);
				Pair pair = (Pair) o;
				pair.clearMessage();
			}

		} catch (NoSuchFieldException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}


	}

	public void addTask(Task task) {
		displayTaskSet.add(task);
	}

	@SuppressWarnings("rawtypes")
	public void clearAllMessages() {
		Class thisClass = Context.class;

		Field[] fields = thisClass.getDeclaredFields();
		for(Field field:fields) {
			Object o;
			try {
				o = field.get(context);
				if (field.getType().equals(Pair.class)) {
					field.setAccessible(true);
					Pair pair = (Pair) o;
					pair.clearMessage();
				}
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}

			displayTaskSet.clear();
		} 
	}

	public void setTaskId(int _taskId) {
		TASKID = _taskId;
	}

	public void setFilePath(String path) {
		FILEPATH = path;
	}

	public void setDefaultDate(String datestring) {
		DEFAULT_DATE = datestring;
	}

	@SuppressWarnings("rawtypes")
	public HashMap<String, Object> getDataModel() {
		Class thisClass = Context.class;
		HashMap<String, Object> dataModel = new HashMap<String, Object>();
		ArrayList<String> success_messages  = new ArrayList<String>();
		ArrayList<String> warning_messages  = new ArrayList<String>();
		ArrayList<String> help_messages     = new ArrayList<String>();
		ArrayList<String> param_messages    = new ArrayList<String>();
		ArrayList<String> error_messages    = new ArrayList<String>();
		ArrayList<String> view_messages     = new ArrayList<String>();
		ArrayList<Task>   taskList          = new ArrayList<Task>();

		Field[] fields = thisClass.getDeclaredFields();
		for(Field field:fields) {
			Object o;
			try {
				o = field.get(context);
				if (field.getType().equals(Pair.class)) {
					field.setAccessible(true);
					Pair pair = (Pair) o;
					if (pair.getValue()) {
						if (field.getName().contains("MESSAGE")) {
							success_messages.add(formatString(field.getName(), pair.getKey()));
						}
						if (field.getName().contains("WARNING")) {
							warning_messages.add(formatString(field.getName(), pair.getKey()));
						}
						if (field.getName().contains("HELP")) {
							help_messages.add(formatString(field.getName(), pair.getKey()));
						}
						if (field.getName().contains("PARAM")) {
							param_messages.add(formatString(field.getName(), pair.getKey()));
						}
						if (field.getName().contains("ERROR")) {
							error_messages.add(formatString(field.getName(), pair.getKey()));
						}
						if (field.getName().contains("VIEW")) {
							view_messages.add(formatString(field.getName(), pair.getKey()));
						}
					}
				}
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
			
		}
		// Add tasks to dataModel
		if (!displayTaskSet.isEmpty()) {
			Iterator<Task> iterator = displayTaskSet.iterator();
			while (iterator.hasNext()) {
				Task task = iterator.next();
				taskList.add(task);
			}
		}
		// Read Json file as string and inject into the HTML template for fullCalendar to render on canvas
		String jsonData = "";
		try {
			String read_string;
			FileReader fr     = new FileReader(FILEPATH);
			BufferedReader br = new BufferedReader(fr);
			
			while ((read_string = br.readLine())!= null) {
				jsonData += read_string;
				
			}								
			br.close();
			
		} catch (IOException e1) {
			e1.printStackTrace();
			
		}
		dataModel.put("success_messages", success_messages);
		dataModel.put("warning_messages", warning_messages);
		dataModel.put("help_messages", help_messages);
		dataModel.put("param_messages", param_messages);
		dataModel.put("error_messages", error_messages);
		dataModel.put("view_messages", view_messages);
		dataModel.put("default_date", DEFAULT_DATE);
		dataModel.put("taskList", taskList);
		dataModel.put("jsonData", jsonData);
		return dataModel;
	}

	// Helper function to add variables into messages just before rendering.
	private String formatString(String field, String original){
		String result;
		if (field == "MESSAGE_ADD_TASK" || field == "MESSAGE_DELETE_TASK" 
			|| field == "MESSAGE_EDIT_TASK" || field == "MESSAGE_UNDO_TASK" 
			|| field == "MESSAGE_REDO_TASK" || field == "MESSAGE_UNDONE_TASK" 
			|| field == "MESSAGE_DONE_TASK" || field == "WARNING_TASK_NOT_EDITED") {
			result = String.format(original, TASKID);
		} else if (field == "MESSAGE_PATH" || field == "MESSAGE_OPEN" 
			|| field == "MESSAGE_SAVE") {
			result = String.format(original, FILEPATH);
		} else {
			result = original;
		}
		return result;
	}
}
```
###### Task\Controller.java
``` java
	 */
	private Controller() {
		// Configure Freemarker
		cfg = new Configuration(Configuration.VERSION_2_3_22);
		
		// Where do we load the templates from:
	    try {
			cfg.setDirectoryForTemplateLoading(new File("./templates/html"));
		} catch (IOException e) {
			e.printStackTrace();
			context.displayMessage("ERROR_HTML_TEMPLATE");
		}
	    
	    // Some other recommended settings:
	    cfg.setIncompatibleImprovements(new Version(2, 3, 20));
	    cfg.setDefaultEncoding("UTF-8");
	    cfg.setLocale(Locale.US);
	    cfg.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
	}

	public static Controller getInstance() {
      if(instance == null) {
         instance = new Controller();
      }
      return instance;
	}

	public static void main(String[] args) {
		LOGGER.setLevel(Level.SEVERE);
		
        TaskHandler.init(args);

        // Start the GUI
        Application.launch(JavaFXGUI.class);
	    
    }
	
	/**
```
###### Task\Controller.java
``` java
	 */
    public void executeGUIInput(String text) {
        TaskHandler.inputFeedBack(text);
        renderView();
        context.clearAllMessages();
		JavaFXGUI.update();
    }

    /**
```
###### Task\Controller.java
``` java
     */
    public void prepareStartUpScreen() {
    	context.displayMessage("MESSAGE_WELCOME");
    	executeGUIInput("display");
    }

    /**
```
###### Task\Controller.java
``` java
     */
    private void renderView() {
        HashMap<String, Object> dataModel = context.getDataModel();
        Template template;  
		Writer fileWriter;
	    try {
	    	fileWriter = new FileWriter(new File("./templates/html/output.html"));
			template = cfg.getTemplate("index.ftl");
	        template.process(dataModel, fileWriter);
	        fileWriter.close();
	    } catch (TemplateException | IOException e) {
	    	context.displayMessage("ERROR_HTML_TEMPLATE");
			e.printStackTrace();
		}
    }
}
```
###### Task\JavaFXGUI.java
``` java
 */

import javafx.application.Platform;
import javafx.application.Application;
import javafx.stage.WindowEvent;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.web.WebView;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.scene.Scene;
import javafx.scene.control.TextField;

public class JavaFXGUI extends Application {
    
    private static Controller controller 			= null;
    private static JavaFXGUI GUI         			= null;
    private static Stage stage           			= null;
    private static TextField tb          			= null;
    private static WebView browser       			= null;
    private static final int WIN_WIDTH 	 			= 1000;
    private static final int WIN_HEIGHT  			= 725;
	private static final double TAB_HEIGHT 			= 20;
	
	public JavaFXGUI() {
		controller = Controller.getInstance();
	}
	
	public static JavaFXGUI getInstance() {
		if (GUI==null) {
			return GUI = new JavaFXGUI();
		} else {
			return GUI;
		}
	}
	
    @Override 
    public void start(Stage _stage) throws Exception {  
    	String template = getClass().getResource("/templates/html/output.html").toExternalForm();
        browser = new WebView(); 
        browser.getEngine().load(template);
        stage = _stage;
        HBox hbox = addHBox();

        // Set grid layout
        BorderPane border = new BorderPane();
        border.setTop(hbox);
        border.setCenter(browser);

        Scene scene = new Scene(border, WIN_WIDTH, WIN_HEIGHT);
        // Handle close button
        stage.setOnCloseRequest(new EventHandler<WindowEvent>() {
            @Override
            public void handle(WindowEvent e) {
              Platform.exit();
              System.exit(0);
           }
        });
        controller.prepareStartUpScreen();
        stage.setScene(scene);  
        stage.setMinWidth(WIN_WIDTH);
        stage.setMinHeight(WIN_HEIGHT + TAB_HEIGHT);
        stage.show();
    } 
    
    /*
    * Creates an HBox with textbox and exit button for the top region
    */   
    private HBox addHBox() {

        HBox hbox = new HBox();
        hbox.setPadding(new Insets(5, 12, 5, 12));
        hbox.setSpacing(10);   // Gap between nodes
        hbox.setStyle("-fx-background-color: #336699;");
        
        tb = new TextField();
        tb.setPrefSize(Integer.MAX_VALUE, TAB_HEIGHT);
        //Setting an action for the textbox
        tb.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                final String userInput = tb.getText();
                Platform.runLater(new Runnable() {
                    @Override
                    public void run() {
                        controller.executeGUIInput(userInput);
                    }
                });
                tb.setText("");
             }
         });
        
        hbox.getChildren().addAll(tb);
        
        return hbox;
    } 

    public static void update() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                String template = getClass().getResource("/templates/html/output.html").toExternalForm(); 
                browser.getEngine().load(template);
            }
        });
    }
}
```
###### Task\Pair.java
``` java
 *
 */
public class Pair {
	private final String key; 
	private boolean value;
	
	public Pair(String k) {
		this.key = k;
		this.value = false;
	}
	
	public String getKey() {
		return this.key;
	}

	public boolean getValue() {
		return this.value;
	}
	
	public void displayMessage() {
		this.value = true;
	}
	
	public void clearMessage() {
		this.value = false;
	}
	
	@Override
	public boolean equals(Object o) {
		if (!(o instanceof Pair)) {
			return false;
		}
		Pair pair_o = (Pair) o;
		return this.key.equals(pair_o.getKey()) 
				&& (this.value == pair_o.getValue());
	}
}
```
###### Task\PARAMETER.java
``` java
 */

public enum PARAMETER {
	DESC,
	VENUE,
	DATE,
	START_DATE,
	END_DATE,
	START_TIME,
	END_TIME,
	DEADLINE_DATE,
	DEADLINE_TIME,
	TASKID,
	IS_DONE,
	IS_PAST,
	HAS_ENDED,
	DELETE_PARAMS,
	SPECIAL
};
```
###### Task\Period.java
``` java
 */

import java.util.Date;
import java.lang.IllegalArgumentException;
import java.text.SimpleDateFormat;

public class Period {
	private Date startDateTime;
	private Date endDateTime;
	
	private static SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/YY HHmm");
	
	public Period (Date startDateTime, Date endDateTime) throws IllegalArgumentException {
		
		if(startDateTime != null && endDateTime != null && startDateTime.after(endDateTime)) {
			throw new IllegalArgumentException("Start time is after end time!");
		}
		this.startDateTime = startDateTime;
		this.endDateTime   = endDateTime;
	}
	
	
	
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Period)) {
			return false;
		}
		
		Period period = ((Period) obj);
		if (!this.startDateTime.equals(period.startDateTime)) {
			return false;
		}
		if (!this.endDateTime.equals(period.endDateTime)) {
			return false;
		}
		
		return true;
	}
	
	public String toString() {
		return dateFormat.format(this.getStartDateTime()) + " - " + dateFormat.format(this.getEndDateTime()); 
	}

	public Date getStartDateTime() {
		return startDateTime;
	}

	public void setStartDateTime(Date startDateTime) {
		this.startDateTime = startDateTime;
	}

	public Date getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(Date endDateTime) {
		this.endDateTime = endDateTime;
	}
}
```
###### Task\Task.java
``` java
 */

public class Task {
	// Helpers
	private static SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy HHmm");
	
	// A task has these meta data
	private Date createdTime;
	private int  taskId;
	
	// A task has these properties
	private Period period          = null;
	private Date deadline          = null;
	private String venue           = null;
	private String description     = null;
	private Boolean isDone         = null;
	private Boolean isPastDeadline = null;
	private Boolean hasEnded       = null;
	
	/**
	 * Constructor for tasks with startTime and endTime only.
	 * Used when user adds a new task
	 * 
	 * @param taskId
	 * @param desc
	 * @param startTime
	 * @param endTime
	 * @param venue
	 */
	public Task (int taskId, String desc, Date startTime, Date endTime, String venue) throws IllegalArgumentException{
		this.createdTime = new Date();
		this.taskId = taskId;
		
		try {
			this.period = new Period(startTime, endTime);
		} catch (IllegalArgumentException e) {
			this.period = null;
			throw e;
		}
		this.deadline = null;
		this.venue = venue;
		this.description = desc;
		setFlags(null);
	}
		
	/**
	 * Constructor for tasks with only deadline and desc.
	 * Used when user adds a new task
	 * 
	 * @param taskId
	 * @param desc
	 * @param deadline
	 * @param venue
	 */
	public Task (int taskId, String desc, Date deadline, String venue) {
		this.createdTime = new Date();
		this.taskId = taskId;
		
		this.period = null;
		this.deadline = deadline;
		this.venue = venue;
		this.description = desc;
		setFlags(false);
	}
	
	/**
	 * Constructor for tasks with startTime, endTime and/or deadline.
	 * To be used when reading from JSON file
	 * 
	 * @param createdTime
	 * @param lastModifiedTime
	 * @param taskId
	 * @param desc
	 * @param startTime
	 * @param endTime
	 * @param deadline
	 * @param venue
	 * @param isDone
	 * @param isPastDeadline
	 * @param hasEnded
	 */
	public Task (Date createdTime, int taskId, String desc, Date startTime, Date endTime, Date deadline, String venue, Boolean isDone) {
		this.createdTime = createdTime;
		this.taskId = taskId;
		
		if (startTime == null || endTime == null) {
			this.period = null;
		} else {
			try {
				this.period = new Period(startTime, endTime);			
			} catch (IllegalArgumentException e) {
				this.period = null;
				System.out.println("Invalid start and end time. Please specify a start time that is before end time.");
			}
		}
		this.deadline = deadline;
		this.venue = venue;
		this.description = desc;
		setFlags(isDone);
	}

	//To be used for tempory tasks
	public Task(int taskId, String desc, String venue, Date startTime, Date endTime, Date deadline, Boolean isDone, Boolean isPastDeadline, Boolean hasEnded) {
		this.createdTime = null;
		this.period = null;
		
		try {
			this.period = new Period(startTime, endTime);			
		} catch (IllegalArgumentException e) {
			this.period = null;
			System.out.println("Invalid start and end time for search");
		}
		
		this.taskId = taskId;
		this.deadline = deadline;
		this.venue = venue;
		this.description = desc;
		this.isDone = isDone;
		this.isPastDeadline = isPastDeadline;
		this.hasEnded = hasEnded;
	}

	public String toString() {
		String startTime;
		String endTime;
		String deadline;
		
		if (this.period == null || this.period.getStartDateTime() == null || this.period.getEndDateTime() == null) {
			startTime = null;
			endTime   = null;
		} else {
			startTime = dateFormat.format(this.period.getStartDateTime());
			endTime   = dateFormat.format(this.period.getEndDateTime());
		}
			
		if (this.deadline == null) {
			deadline = null;
		} else {
			deadline = dateFormat.format(this.getDeadline());
		}
		
		String result = "";
		result += "Task :\n";
		result += "   Task ID           : " + this.taskId + "\n";
		result += "   Description       : " + this.description + "\n";
		result += "   Start Time        : " + startTime + "\n";
		result += "   End Time          : " + endTime + "\n";
		result += "   Deadline          : " + deadline + "\n";
		result += "   Venue             : " + this.venue + "\n";
		result += "   Completed?        : " + this.isDone + "\n";
		result += "   Is Past Deadline? : " + this.isPastDeadline + "\n";
		result += "   Has Ended?        : " + this.hasEnded + "\n";
		
		return result;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Task)) {
			return false;
		}
		Task task = ((Task)obj);

		if (!bothNullOrEqual(this.period, task.period)) {
			return false;
		}
		if (!bothNullOrEqual(this.deadline, task.deadline)) {
			return false;
		}
		if (!bothNullOrEqual(this.venue, task.venue)) {
			return false;
		}
		if (!bothNullOrEqual(this.description, task.description)) {
			return false;
		}
		if (this.isDone != task.isDone) {
			return false;
		}
		if (this.isPastDeadline != task.isPastDeadline) {
			return false;
		}
		if (this.hasEnded != task.hasEnded) {
			return false;
		}
		
		return true;
	}
	
	// Utility method
	private static boolean bothNullOrEqual(Object x, Object y) {
		return ( x == null ? y == null : x.equals(y));
	}
	
	public void setFlags(Boolean _isDone) {
		if(this.getStartDateTime() == null || this.getEndDateTime() == null){
			setDone(_isDone);
		}
		if(this.getDeadline() != null){
			setPastDeadline();
		}
		if(this.getStartDateTime() != null && this.getEndDateTime() != null){
			setEnded();
		}
	}
	
	public void setPastDeadline () {
		this.isPastDeadline = isPastDeadline(new Date() , this.deadline);
	}
	
	public Boolean isPastDeadline (Date now, Date deadline) {
		if(now == null || deadline == null){
			return null;
		}
		return now.after(deadline);
	}
	
	public void setEnded () {
		this.hasEnded = hasEnded(new Date() , this.getEndDateTime());
	}

	public Boolean hasEnded ( Date now, Date endTime) {
		if(now == null || endTime == null){
			return null;
		}
		return now.after(endTime);
	}
	
	public Date getCreatedTime() {
		return this.createdTime;
	}

	public int getTaskId() {
		return this.taskId;
	}

	public void setTaskId(int taskId) {
		this.taskId = taskId;
	}

	public Date getStartDateTime() {
		if (this.period == null) {
			return null;
		} else {
			return this.period.getStartDateTime();			
		}
	}

	public void setStartDateTime(Date startTime) {
		if (this.period == null) {
			// Assume default endTime one hour from startTime
			Date endTime = new Date(startTime.getTime() + (60L * 60L * 1000L));
			this.period = new Period(startTime, endTime);
		} else {			
			this.period.setStartDateTime(startTime);
		}
	}

	public Date getEndDateTime() {
		if (this.period == null) {
			return null;
		} else {
			return this.period.getEndDateTime();			
		}
	}

	public void setEndDateTime(Date endTime) {
		if (this.period == null) {
			// Assume default startTime one hour before startTime
			Date startTime = new Date(endTime.getTime() - (60L * 60L * 1000L));
			this.period = new Period(startTime, endTime);
		} else {
			this.period.setEndDateTime(endTime);			
		}
	}

	public Period getPeriod() {
		return this.period;
	}
	
	public void setPeriod(Period _period) {
		this.period = _period;
	}

	public Date getDeadline() {
		return deadline;
	}

	public void setDeadline(Date deadline) {
		this.deadline = deadline;
	}

	public String getVenue() {
		return venue;
	}

	public void setVenue(String venue) {
		this.venue = venue;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Boolean isDone() {
		return isDone;
	}

	public void setDone(Boolean isDone) {
		this.isDone = isDone;
	}

	public Boolean isPastDeadline() {
		return isPastDeadline;
	}

	// Determines if a deadline task is past deadline
	public Boolean determinePastDeadline() {
		if (this.deadline != null) {
			if (this.deadline.after(new Date())) {
				return false;
			} else {
				return true;
			}
		} else {
			return null;
		}
	}

	public void setPastDeadline(Boolean isPastDeadline) {
		this.isPastDeadline = isPastDeadline;
	}

	public Boolean isHasEnded() {
		return hasEnded;
	}

	public void setHasEnded(Boolean hasEnded) {
		this.hasEnded = hasEnded;
	}

	public boolean isFloating() {
		if (this.period == null && this.deadline == null) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * @@ author A0009586
	 */
	public boolean isEmpty() {
		return
			taskId			== -1 				&&
			(period          == null			||
			(period.getEndDateTime() == null && 
			period.getStartDateTime() == null))	&&
			deadline   		== null				&&
			venue           == null				&&
			description     == null				&&
			isDone         	== null				&&
			isPastDeadline 	== null				&&
			hasEnded       	== null;
	}
}
```
###### Task\TaskHandler.java
``` java
 */
@SuppressWarnings("unused")
public class TaskHandler {
	private static final Logger LOGGER = Logger.getLogger(TaskHandler.class.getName());
	
	private static final boolean TASK_DONE    	= true;
	private static final boolean TASK_NOT_DONE	= false;
	
	private static final int ALL_TASKS = -2;
	
	private static Calendar             calendar        = Calendar.getInstance();
	private static SimpleDateFormat     dateFormat      = new SimpleDateFormat("dd/M/yyyy HHmm");
	private static ArrayList<Task>      taskList        = new ArrayList<Task>(50);
	private static String 			    defaultFilePath = "./data/calendar.json";		// relative path to calendar.json 
	private static int 				    currentTaskId;          
	private static FileIO               fileIO;
	private static TaskUndoManager      undoManager;
	private static Context              context         = Context.getInstance();
	
	/**
	 * Initialize settings, search for application files etc.
	 * @param args The file path to load the file in
	 * @return 
	 */
	public static void init(String[] args) {
		String localFilePath = determineFilePath(args);
		LOGGER.setLevel(Level.INFO);
		undoManager   = new TaskUndoManager();
		dateFormat.setCalendar(calendar);
		fileIO        = FileIO.getInstance();
		fileIO.setFilePath(localFilePath);
		taskList      = fileIO.readFromFile();
		currentTaskId = fileIO.getMaxTaskId();
		context.clearAllMessages();
		updateTaskStatus();
	}
	
	public static void inputFeedBack(String input){
		if(isValidCommand(input)) {
			executeCommand(input);
		}
	}

	private static String determineFilePath(String[] args) {
		String localFilePath;
		if (args.length == 1) {
			localFilePath = args[0];
		} else {
			localFilePath = TaskHandler.defaultFilePath;
		}
		return localFilePath;
	}


	/**
	 * Pattern matching on expected command patterns to decide if it is a valid command
	 * @param userInput
	 * @return
	 */
	public static boolean isValidCommand(String userInput) {
		if(userInput.length() != 0) {
			return true;
		} else {
			showHelpMenu();
			return false;
		}
	}
	
	/**
	 * Executes user input
	 * @param userInput The input to be executed
	 * @return The feedback to give to the user
	 */
	public static void executeCommand(String userInput) {
		COMMAND_TYPE command = determineCommandType(getFirstWord(userInput));
		HashMap<PARAMETER, Object> parsedParamTable;
		switch (command) {
			case PATH:
				String filepath = removeFirstWord(userInput);
				if (fileIO.setFilePath(filepath)) {
					context.displayMessage("MESSAGE_PATH");
				} else {
					context.displayMessage("HELP_PATH");
				};
				break;
			case FILEOPEN:
				taskList = fileIO.readFromFile();
				context.displayMessage("MESSAGE_OPEN");
				context.displayMessage("MESSAGE_DISPLAY_ALL");
				displayFloatingTasks(taskList);
				break;
			case FILESAVE:
				fileIO.writeToFile(taskList);
				context.displayMessage("MESSAGE_SAVE");
				break;
			case ADD_TASK:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				//TODO: shouldn't it be if it has a description?
				if (parsedParamTable.get(PARAMETER.DESC) != null) {
					addTask((String)parsedParamTable.get(PARAMETER.DESC),
						(String)parsedParamTable.get(PARAMETER.VENUE), 
						(Date)parsedParamTable.get(PARAMETER.START_DATE),
						(Date)parsedParamTable.get(PARAMETER.END_DATE), 
						(Date)parsedParamTable.get(PARAMETER.START_TIME),
						(Date)parsedParamTable.get(PARAMETER.END_TIME),
						(Date)parsedParamTable.get(PARAMETER.DEADLINE_DATE),
						(Date)parsedParamTable.get(PARAMETER.DEADLINE_TIME));
	
					fileIO.writeToFile(taskList);
				} else {
					context.displayMessage("ERROR_INVALID_COMMAND");
					context.displayMessage("HELP_ADD_TASK");
				}
				break;
			case DISPLAY:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				if (taskList.isEmpty()) {
					context.displayMessage("ERROR_EMPTY_TASKLIST");
				} else if(removeFirstWord(userInput).length() != 0){
					if(searchTasks(parsedParamTable).size() == 0){
						context.displayMessage("ERROR_NO_RESUlTS_FOUND");
					} else {
						context.displayMessage("MESSAGE_DISPLAY");
						displayAllTasks(searchTasks(parsedParamTable));	
					}			
				} else {
					context.displayMessage("MESSAGE_DISPLAY_ALL");
					displayFloatingTasks(taskList);
				}
				setCalendarView(parsedParamTable);
				break;
			case EDIT_TASK:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				editTask((int)parsedParamTable.get(PARAMETER.TASKID),
					(PARAMETER[])parsedParamTable.get(PARAMETER.DELETE_PARAMS),
					(String)parsedParamTable.get(PARAMETER.DESC),
					(String)parsedParamTable.get(PARAMETER.VENUE), 
					(Date)parsedParamTable.get(PARAMETER.START_DATE),
					(Date)parsedParamTable.get(PARAMETER.END_DATE), 
					(Date)parsedParamTable.get(PARAMETER.START_TIME),
					(Date)parsedParamTable.get(PARAMETER.END_TIME),
					(Date)parsedParamTable.get(PARAMETER.DEADLINE_DATE),
					(Date)parsedParamTable.get(PARAMETER.DEADLINE_TIME));
				
				fileIO.writeToFile(taskList);
				break;
			case DELETE_TASK:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				removeTask((int)parsedParamTable.get(PARAMETER.TASKID));
				fileIO.writeToFile(taskList);
				break;
			case UNDO:
				undoSingleCommand();
				fileIO.writeToFile(taskList);
				break;
			case REDO:
				redoSingleCommand();
				fileIO.writeToFile(taskList);
				break;
			case DONE:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				completeTask((int)parsedParamTable.get(PARAMETER.TASKID),TASK_DONE);
				fileIO.writeToFile(taskList);
				break;
			case UNDONE:
				parsedParamTable = StringParser.getValuesFromInput(command, removeFirstWord(userInput));
				completeTask((int)parsedParamTable.get(PARAMETER.TASKID), TASK_NOT_DONE);
				fileIO.writeToFile(taskList);
				break;
			case HELP:
				showHelpMenu();
				break;
			case EXIT:
				context.displayMessage("MESSAGE_EXIT");
				fileIO.writeToFile(taskList);
				Platform.exit();
				System.exit(0);
			default: //Add task
				parsedParamTable = StringParser.getValuesFromInput(COMMAND_TYPE.ADD_TASK, userInput);
				//TODO: shouldn't it be if it has a description?
				if (parsedParamTable.get(PARAMETER.DESC) != null) {
					addTask((String)parsedParamTable.get(PARAMETER.DESC),
						(String)parsedParamTable.get(PARAMETER.VENUE), 
						(Date)parsedParamTable.get(PARAMETER.START_DATE),
						(Date)parsedParamTable.get(PARAMETER.END_DATE), 
						(Date)parsedParamTable.get(PARAMETER.START_TIME),
						(Date)parsedParamTable.get(PARAMETER.END_TIME),
						(Date)parsedParamTable.get(PARAMETER.DEADLINE_DATE),
						(Date)parsedParamTable.get(PARAMETER.DEADLINE_TIME));
	
					fileIO.writeToFile(taskList);
				} else {
					context.displayMessage("ERROR_INVALID_COMMAND");
					context.displayMessage("HELP_ADD_TASK");
				}
				break;
		
		}
		
		updateAllTaskFlags(taskList);
	}

	private static void updateAllTaskFlags(ArrayList<Task> taskList) {
		for(Task t:taskList){
			t.setFlags(t.isDone());
		}
		
	}

	/**
	 * TODO:
	 * @param i
	 * @param taskDone
	 * @return
	 */
	private static void completeTask(int taskID, Boolean isDone) {
		boolean notFound = true;
		for (Task t:taskList){
			if (t.getTaskId() == taskID){
				Boolean prevDone      = t.isDone();
				TaskEdit compoundEdit = new TaskEdit(t);
				TaskDoneEdit edit     = new TaskDoneEdit(t, prevDone, isDone);
				edit.setSignificant();
				compoundEdit.addEdit(edit);
				compoundEdit.end();
				t.setDone(isDone);
				undoManager.addEdit(compoundEdit);
				if (isDone) {
					context.displayMessage("MESSAGE_DONE_TASK");
				} else {
					context.displayMessage("MESSAGE_UNDONE_TASK");					
				}
				context.setTaskId(t.getTaskId());
				context.addTask(t);
				notFound = false;
			}
		}
		if (notFound) {
			context.displayMessage("ERROR_TASK_NOT_FOUND");
		}
	}

	private static void undoSingleCommand() {
		try {
			if (undoManager.canUndo()) {
				UndoableEdit nextEdit = undoManager.editToBeUndone();
				TaskEdit taskEdit = (TaskEdit) nextEdit;
				undoManager.undo();
				context.addTask(taskEdit.getTask());
				context.displayMessage("MESSAGE_UNDO_TASK");
				context.setTaskId(taskEdit.getTask().getTaskId());
			} else {
				context.displayMessage("ERROR_CANNOT_UNDO");
			}
		} catch (CannotUndoException e) {
			context.displayMessage("ERROR_CANNOT_REDO");
		}
	}

	private static void redoSingleCommand() {
		try {
			if (undoManager.canRedo()) {
				UndoableEdit nextEdit = undoManager.editToBeRedone();
				TaskEdit taskEdit = (TaskEdit) nextEdit;
				undoManager.redo();
				context.addTask(taskEdit.getTask());
				context.displayMessage("MESSAGE_REDO_TASK");
				context.setTaskId(taskEdit.getTask().getTaskId());
			} else {
				context.displayMessage("ERROR_CANNOT_REDO");
			}
		} catch (CannotRedoException e) {
			context.displayMessage("ERROR_CANNOT_UNDO");
		}
	}

	/**
	 * Edits a task in the task list
	 * @param task The task to be added to the taskList
	 * @return 
	 */
	private static void editTask(int ID, PARAMETER[] deleteParams, String desc,String venue, Date startDate, Date endDate, Date startTime, Date endTime, Date deadlineDate, Date deadlineTime) {
		// Declare local variables
		SimpleDateFormat timeFormat      = new SimpleDateFormat("HHmm");

		Task task          = null;
		Date _deadlineDate = null;
		Date prevStartDate;
		Date prevEndDate;
		Date prevDeadlineDate;
		Period oldPeriod = null;
		Period newPeriod;
		
		String prevStartTime 	= "1200";
		String prevEndTime 		= "1300";
		String prevDeadlineTime = null;

		boolean isUpdated = false;
		Boolean prevIsdone;
		
		if (ID != -1){
			task = getTask(ID);
			if (task == null) {
				context.displayMessage("ERROR_TASK_NOT_FOUND");
				return;			// Terminate execution
			}
		} else {
			context.displayMessage("PARAM_SUBTITLE");
			context.displayMessage("PARAM_TASKID_NULL");
			return; 			// Terminate execution
		}
		
		UndoableSignificantEdit edit = new UndoableSignificantEdit();
		TaskEdit compoundEdit        = new TaskEdit(task);
		// Set description
		if (desc != null){
			String oldDesc = task.getDescription();
			edit = new TaskDescEdit(task, oldDesc, desc);
			task.setDescription(desc);
			compoundEdit.addEdit(edit);
			isUpdated = true;
		}
		
		// Set venue
		if (venue != null){
			String oldVenue = task.getVenue();
			task.setVenue(venue);
			edit = new TaskVenueEdit(task, oldVenue, venue);
			compoundEdit.addEdit(edit);
			isUpdated = true;
		}

		prevStartDate    = task.getStartDateTime();
		prevEndDate      = task.getEndDateTime();
		prevDeadlineDate = task.getDeadline();
		if(prevStartDate != null && prevEndDate != null){
			// Get the original time of the day for start and end of the event
			prevStartTime    = timeFormat.format(prevStartDate);
			prevEndTime      = timeFormat.format(prevEndDate);
			oldPeriod        = new Period(prevStartDate, prevEndDate);
		}
		
		prevIsdone 			= task.isDone();
		
		if (prevDeadlineDate != null) {
			prevDeadlineTime = timeFormat.format(prevDeadlineDate);
		}
		
		try {
			// Set startDate, startTime, endDate and endTime
			// E.g. edit 2 from 12/10/15 1200 to 13/10/15 1400
			// E.g. edit 2 on 12/10/15 from 1200 to 1400
			if (startDate != null && startTime != null && endDate != null && endTime != null){
				newPeriod = new Period(startTime, endTime);
				task.setStartDateTime(startTime);
				task.setEndDateTime(endTime);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				
				compoundEdit.addEdit(edit);
				isUpdated  = true;
			}

			// Set startDate and endDate, without changing startTime and endTime
			// E.g. edit 2 on 12/10/15
			if (startDate != null && startTime == null && endDate != null && endTime == null) {
				
				startDate	= changeDateTime(startDate, prevStartTime);
				endDate		= changeDateTime(endDate, prevEndTime);
				
				task.setStartDateTime(startDate);
				task.setEndDateTime(endDate);

				newPeriod = new Period(startDate, endDate);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated     = true;
			}
			
			// Set startDate, startTime
			// E.g. edit 2 from 12/10/15 1200
			if (startDate != null && startTime != null && endDate == null && endTime == null && prevEndDate != null) {
				newPeriod = new Period(startTime, prevEndDate);
				
				task.setStartDateTime(startTime);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated  = true;
			}

			// Set startDate, startTime according to user; endDate, endTime remains unchanged
			// E.g. edit 2 on 12/10/15 from 1400
			if (startDate != null && startTime != null && endDate != null && endTime == null && prevEndDate != null) {
				newPeriod = new Period(startTime, prevEndDate);

				task.setStartDateTime(startTime);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated  = true;
			}
			
			// Set startDate only
			// E.g. edit 2 from 12/10/15
			if (startDate != null && startTime == null && endDate == null && endTime == null && prevEndDate != null) {								
				startDate = changeDateTime(startDate, prevStartTime);
				newPeriod = new Period(startDate, prevEndDate);

				task.setStartDateTime(startDate);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated     = true;
			}
			
			// Set endDate, endTime
			// E.g. edit 2 to 12/10/15 1400
			if (startDate == null && startTime == null && endDate != null && endTime != null && prevEndDate != null) {
				newPeriod = new Period(prevStartDate, endTime);

				task.setEndDateTime(endTime);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated = true;
			}
			
			// Set endDate, endTime according to user; startDate, startTime remains unchanged
			// E.g. edit 2 on 12/10/15 to 1600
			if (startDate != null && startTime == null && endDate != null && endTime != null && prevStartDate != null && prevEndDate != null) {
				startDate = changeDateTime(startDate, prevStartTime);
				newPeriod = new Period(startDate, endTime);

				task.setEndDateTime(endTime);
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated = true;
			}	

			// Set endDate only
			// E.g. edit 2 to 12/10/15
			if (startDate == null && startTime == null && endDate != null && endTime == null && prevStartDate != null) {				
				endDate    = changeDateTime(endDate, prevEndTime);
				
				newPeriod = new Period(prevStartDate, endDate);
				
				task.setEndDateTime(endDate);	
				edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
				compoundEdit.addEdit(edit);
				isUpdated   = true;			
			}

			// Set deadlineDate and deadlineTime
			if (deadlineDate != null && deadlineTime != null){
				task.setDeadline(deadlineTime);
				edit = new TaskDeadlineEdit(task, prevDeadlineDate, deadlineTime);
				compoundEdit.addEdit(edit);
				isUpdated     = true;
			}
			
			// Set deadlineDate and deadlineTime
			if (deadlineDate != null && deadlineTime == null && prevDeadlineTime != null){				
				_deadlineDate = changeDateTime(deadlineDate, prevDeadlineTime);
				task.setDeadline(_deadlineDate);
				edit = new TaskDeadlineEdit(task, prevDeadlineDate, _deadlineDate);
				compoundEdit.addEdit(edit);
				isUpdated        = true;
			}
			
			if(deleteParams != null){
				for(PARAMETER p:deleteParams){
					if(p != null){
						if(p.equals(PARAMETER.START_TIME)||p.equals(PARAMETER.END_TIME)){
							task.setPeriod(null);
							newPeriod = null;
							edit = new TaskPeriodEdit(task, oldPeriod, newPeriod);
							compoundEdit.addEdit(edit);
						} else if (p.equals(PARAMETER.DEADLINE_TIME)){
							task.setDeadline(null);
							edit = new TaskDeadlineEdit(task, prevDeadlineDate, _deadlineDate);
							compoundEdit.addEdit(edit);
							if(task.getStartDateTime() != null){
								edit = new TaskDoneEdit(task, prevIsdone, null);
								compoundEdit.addEdit(edit);
							}
						} else if(p.equals(PARAMETER.VENUE)){
							String oldVenue = task.getVenue();
							task.setVenue(null);
							edit = new TaskVenueEdit(task, oldVenue, venue);
							compoundEdit.addEdit(edit);
						} else if(p.equals(PARAMETER.DESC)){
							String oldDesc = task.getDescription();
							edit = new TaskDescEdit(task, oldDesc, null);
							task.setDescription(null);
							compoundEdit.addEdit(edit);
						}
						
						isUpdated        = true;
					}
				}
			}
			
			if(isUpdated) {
				// Set one significant edit
				UndoableEdit lastEdit = compoundEdit.lastEdit();
				UndoableSignificantEdit edit1 = (UndoableSignificantEdit) lastEdit;
				compoundEdit.end();
				edit1.setSignificant();
				undoManager.addEdit(compoundEdit);
				context.displayMessage("MESSAGE_EDIT_TASK");
			} else {
				context.displayMessage("WARNING_TASK_NOT_EDITED");
				context.displayMessage("HELP_HEADING");				
				context.displayMessage("HELP_EDIT_TASK");
			}
			context.addTask(task);
			context.setTaskId(task.getTaskId());
		} catch (ParseException e) {			
			e.printStackTrace();
			context.displayMessage("ERROR_DATEFORMAT");
		} catch (IllegalArgumentException e) {
			e.printStackTrace();
			context.displayMessage("ERROR_START_BEFORE_END");
		}
	}

	/**
	 * Adds a task to the task list
	 * @param task The task to be added to the taskList
	 */
	private static void addTask(String desc, String venue, Date startDate, Date endDate, Date startTime, Date endTime, Date deadlineDate, Date deadlineTime) {
		if(desc != null){
			Task task = null;
			
			try{
				task = createTask(currentTaskId+1, desc, venue, startDate, endDate, startTime, endTime, deadlineDate, deadlineTime);
			} catch (IllegalArgumentException e){
				context.displayMessage("ERROR_START_BEFORE_END");
			}
			
			// Make sure that we are not adding a null Task
			assert(task!=null);

			TaskEdit compoundEdit = new TaskEdit(task);
			TaskListEdit edit     = new TaskListEdit(task, taskList, currentTaskId, currentTaskId+1,true);
			edit.setSignificant();
			compoundEdit.addEdit(edit);
			compoundEdit.end();

			taskList.add(task);
			undoManager.addEdit(compoundEdit);
			currentTaskId += 1;
			context.addTask(task);
			context.displayMessage("MESSAGE_ADD_TASK");
		} else {
			context.displayMessage("ERROR_NO_DESC");
		}
	}
	
	/**
	 * Creates a new task using the suitable contructor based on whatever information we have
	 */
	private static Task createTask(int taskID, String desc, String venue, Date startDate, 
			Date endDate, Date startTime, Date endTime, Date deadlineDate, Date deadlineTime) throws IllegalArgumentException{
		if (startTime != null && endTime != null){
			return new Task(taskID, desc, startDate, endDate, venue);// Event
		} else if (deadlineDate != null){
			return new Task(taskID, desc, deadlineDate, venue);		// Deadline task
		} else {
			return new Task(taskID, desc, null, venue);				// Floating task
		}
	}
	
	/**
	 * Remove a specific task from the file
	 * @param task The task to be deleted from the taskList
	 */
	private static void removeTask(int taskID) {
		Task task = getTask(taskID);

		if (taskList.remove(task)) {
			TaskEdit compoundEdit = new TaskEdit(task);
			TaskListEdit edit     = new TaskListEdit(task, taskList, currentTaskId, currentTaskId,false);
			edit.setSignificant();
			compoundEdit.addEdit(edit);
			compoundEdit.end();
			undoManager.addEdit(compoundEdit);
			context.addTask(task);
			context.displayMessage("MESSAGE_DELETE_TASK");
			context.setTaskId(task.getTaskId());

		} else if(taskID == ALL_TASKS && taskList.size() > 0){
			task = taskList.get(0);
			TaskEdit compoundEdit = new TaskEdit(task);
			TaskListEdit edit     = new TaskListEdit(taskList, currentTaskId, currentTaskId,false);
			edit.setSignificant();
			while(taskList.size() != 0){
				task = taskList.get(0);
				taskList.remove(task);
			}
			compoundEdit.addEdit(edit);
			compoundEdit.end();
			undoManager.addEdit(compoundEdit);
			context.displayMessage("MESSAGE_DISPLAY_ALL");
		} else {
			context.displayMessage("ERROR_TASK_NOT_FOUND");		
		}
	}
	
	/**
	 * Shows the Help menu to the user
	 */
	private static void showHelpMenu() {
		context.displayMessage("HELP_TITLE");
		context.displayMessage("HELP_HEADING");
		context.displayMessage("HELP_SUBTITLE");
		context.displayMessage("HELP_ADD_TASK");
		context.displayMessage("HELP_PATH");
		context.displayMessage("HELP_FILEOPEN");
		context.displayMessage("HELP_FILESAVE");
		context.displayMessage("HELP_DISPLAY");
		context.displayMessage("HELP_EDIT_TASK");
		context.displayMessage("HELP_UNDO");
		context.displayMessage("HELP_REDO");
		context.displayMessage("HELP_DONE");
		context.displayMessage("HELP_UNDONE");
		context.displayMessage("HELP_DELETE_TASK");
		context.displayMessage("HELP_HELP");
		context.displayMessage("HELP_EXIT");
	}
	
	/**
	 * Displays all the current tasks in the taskList
	 */
	private static void displayAllTasks(ArrayList<Task> list) {
		for(Task task:list) {
			context.addTask(task);
		}
	}

	/**
	 * Displays only floating tasks
	 */
	private static void displayFloatingTasks(ArrayList<Task> list) {
		for(Task task:list) {
			if (task.isFloating()) {
				context.addTask(task);
			}
		}
	}
	
	/**
```
###### Task\TaskHandler.java
``` java
	 * Takes a single word and figure out the command
	 * @param commandTypeString The string containing a command
	 * @return The enum value corresponding to the commandTypeString
	 */
	private static COMMAND_TYPE determineCommandType(String commandTypeString) {
		if (commandTypeString == null) {
			throw new Error("command type string cannot be null!");
		}
		
		if (commandTypeString.equalsIgnoreCase("path")) {
			return COMMAND_TYPE.PATH;
		} else if (commandTypeString.equalsIgnoreCase("fileopen")) {
			return COMMAND_TYPE.FILEOPEN;
		} else if (commandTypeString.equalsIgnoreCase("filesave")) {
			return COMMAND_TYPE.FILESAVE;
		} else if (commandTypeString.equalsIgnoreCase("add")) {
			return COMMAND_TYPE.ADD_TASK;
		} else if (commandTypeString.equalsIgnoreCase("get")) {
			return COMMAND_TYPE.GET_TASK;
		} else if (commandTypeString.equalsIgnoreCase("display")) {
			return COMMAND_TYPE.DISPLAY;
		} else if (commandTypeString.equalsIgnoreCase("edit")) {
			return COMMAND_TYPE.EDIT_TASK;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return COMMAND_TYPE.DELETE_TASK;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return COMMAND_TYPE.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("done")) {
			return COMMAND_TYPE.DONE;
		} else if (commandTypeString.equalsIgnoreCase("undone")) {
			return COMMAND_TYPE.UNDONE;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return COMMAND_TYPE.REDO;
		} else if (commandTypeString.equalsIgnoreCase("exit")) {
			return COMMAND_TYPE.EXIT;
		} else if (commandTypeString.equalsIgnoreCase("help")) {
			return COMMAND_TYPE.HELP;
		} else {
			return COMMAND_TYPE.INVALID_COMMAND;
		}
	}
	
	/**
	 * Gets the first word from a string
	 * @param userCommand The string containing one or more words
	 * @return The first word in the string
	 */
	private static String getFirstWord(String userCommand) {
		String commandTypeString = userCommand.trim().split("\\s+")[0];
		return commandTypeString;
	}
	
	/**
	 * Removes the first word from a string and returns the second word
	 * @param userCommand The string to be split
	 * @return The original string without the first word
	 */
	private static String removeFirstWord(String userCommand) {
		String[] parameters = userCommand.trim().split(" ", 2);
		if(parameters.length > 1){
			return parameters[1];
		} else{
			return "";
		}
	}

	/**
	 * Allow TaskListEdit to set currentTaskId for undo and redo operations
	 * @param taskID
	 */
	public static void setCurrentTaskId(int _currentTaskId) {
		currentTaskId = _currentTaskId;
	}

	private static void updateTaskStatus() {
		for (Task t : taskList) {
			Boolean new_status = t.determinePastDeadline();
			t.setPastDeadline(new_status);
		}
	}

	/**
	 * For display commands, set defaultDate in context with the correct defaultDate 
	 * so that fullCalendar can render the right date.
	 * @param paramTable
	 */
	private static void setCalendarView(HashMap<PARAMETER,Object> paramTable) {
		// FullCalendar uses moments.js which prefers ISO8601 formatted date strings
		SimpleDateFormat ISO8601 = new SimpleDateFormat("YYYY-MM-dd");
		if (paramTable.get(PARAMETER.START_DATE) != null) {
			context.setDefaultDate(ISO8601.format((Date)paramTable.get(PARAMETER.START_DATE)));
		} else if (paramTable.get(PARAMETER.DEADLINE_DATE) != null) {
			context.setDefaultDate(ISO8601.format((Date)paramTable.get(PARAMETER.DEADLINE_DATE)));
		}
	}

	// Utility function
	private static Date changeDateTime(Date date, String prevTimeString) throws ParseException {
		String test1 = dateFormat.format(date);
		return new SimpleDateFormat("dd/M/yyyy HHmm").parse(test1.split(" ")[0] + " " + prevTimeString);
	}
}
```
