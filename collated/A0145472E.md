# A0145472E
###### Task\Controller.java
``` java
 */

public class Controller{
	private static Configuration cfg;
	private static Context context = Context.getInstance();
	private static Controller instance = null;
	
	private final static Logger LOGGER = Logger.getLogger(StringParser.class.getName());
	
	/**
```
###### Task\FileIO.java
``` java
	 * 
	 * Used to check is a path has a valid directory
	 * @param path The path to be evaluated
	 * @return is the path directory valid
	 */
	private boolean isValidDirectory(String path) {
		File file = new File(FilenameUtils.getPath(path));
		return file.isDirectory();
	}
	
	/**
	 * @@ author A0097689
	 */
	// Utility method
		private Boolean parseNullOrBool(JsonReader jsonReader) throws IOException {
			if (jsonReader.peek() == JsonToken.NULL) {
				jsonReader.nextNull();
				return null;
			} else {
				return jsonReader.nextBoolean();
			}
		}

	// Utility method
	private String parseNullOrString(JsonReader jsonReader) throws IOException {
		if (jsonReader.peek() == JsonToken.NULL) {
			jsonReader.nextNull();
			return null;
		} else {
			return jsonReader.nextString();
		}
	}
	
	// Utility method
	private String toNullOrDateString(Date date) {
		if (date == null) {
			return null;
		} else {
			return dateFormat.format(date);
		}
	}
}
```
###### Task\StringParser.java
``` java
 *  @author Jean Castillo
 *  
 *  Represents the parser for strings
 * 
 */

package Task;

import java.text.ParseException;
import java.util.HashMap;


public class StringParser {
	//Define String constants here
	private static final String SPACE_CHARACTER = "\\s+";
	
	//Define int constants here
	private static final int QUOTE_INTEGER = 34;
	private static final int PARAM_NOT_FOUND = -1;
	private static final String ALL_TASKS = "-2";
	
	private static String[] 	AllKeywordsInInput	={"on","from","to","by","do","at"};
	private static String[] 	daysInInput			={"monday","tuesday","wednesday","thursday","friday","saturday","sunday",
														"today","tomorrow","tmr"};
	private static String[] 	taskTypes			={"deadline","floating","event"};
	private static String[]		taskTypeDel			={"from to","from to by","by"};
	
	private static String[]		searchTypeDone		={"done"};
	private static String[]		searchTypeEnded		={"ended"};
	private static String[]		searchTypePast		={"past"};
	private static String[]		searchTypeAll		={"all"};
	

	private static String[] 	keywordsInInput		={"on ","from ","to ","by "};
	private static PARAMETER[] 	paramInInput		={PARAMETER.DATE,
														PARAMETER.START_TIME,
														PARAMETER.END_TIME,
														PARAMETER.DEADLINE_TIME,
														};
	

	
	/**
	 * Used to get a HashMap from user input and a command type
	 * @param command The type of command used to treat the userInput differently
	 * @param userInput The string from the user
	 * @return The hashmap with valid task inputs
	 * @throws ParseException Used to detect user errors in input
	 */
	public static HashMap<PARAMETER, Object> getValuesFromInput(COMMAND_TYPE command, String userInput) {
		
		HashMap<PARAMETER, String> keywordHash = new HashMap<PARAMETER, String>(0);
		
		getStringHashMap(command, userInput, keywordHash);
		
		return Validator.getObjectHashMap(keywordHash, command);
	}

	public static void getStringHashMap(COMMAND_TYPE command, String userInput, HashMap<PARAMETER, String> keywordHash) {
		boolean isDeleteParams = false;
		
		userInput = userInput.trim();
		
		switch (command) {
		
		case DELETE_TASK:
			
		case DONE:
			
		case UNDONE:
			getTaskID(userInput, keywordHash);
			break;
			
		case DISPLAY:
			getTaskID(userInput, keywordHash);
			//Take the "" keywords out
			userInput = transferQuoteToHashMap(PARAMETER.DESC,"do",userInput, keywordHash);
			userInput = transferQuoteToHashMap(PARAMETER.VENUE,"at",userInput, keywordHash);
			
			if(keywordHash.get(PARAMETER.DESC) == null){
				userInput = transferQuoteToHashMap(PARAMETER.DESC,"",userInput, keywordHash);
			}
			
			addAttributesWithoutKeyword(keywordsInInput, paramInInput, userInput.split(obtainDelimiterStringList(keywordsInInput)), keywordHash);
			
			if(keywordHash.get(PARAMETER.START_TIME) == null && keywordHash.get(PARAMETER.END_TIME) == null && keywordHash.get(PARAMETER.DEADLINE_TIME) == null){
				addAttributesWithOneParamKeyword(daysInInput, PARAMETER.DATE, userInput.split(obtainDelimiterStringList(daysInInput)), keywordHash);
			}
			
			addAttributesFromList(searchTypeDone,PARAMETER.IS_DONE, userInput, keywordHash);
			addAttributesFromList(searchTypeEnded,PARAMETER.HAS_ENDED, userInput, keywordHash);
			addAttributesFromList(searchTypePast,PARAMETER.IS_PAST, userInput, keywordHash);
			addAttributesFromList(searchTypeAll,PARAMETER.SPECIAL, userInput, keywordHash);
			
			break;
			
		case EDIT_TASK:
			getTaskID(userInput, keywordHash);
			isDeleteParams = findKeywordIndexInput(userInput.trim(),"no", 0) != PARAM_NOT_FOUND;
			//Take the no keywords out
			if(isDeleteParams){
				userInput = obtainTrailingKeywordsToHashmap(userInput, findKeywordIndexInput(userInput.trim(),"no ", 0),
								"no ".length(),AllKeywordsInInput,PARAMETER.DELETE_PARAMS,keywordHash);
			}
			
			
			addStringToParamFromList(userInput,taskTypes,taskTypeDel,PARAMETER.DELETE_PARAMS,keywordHash);
			removeRepeatedWordsParam(PARAMETER.DELETE_PARAMS,keywordHash);			
			
		case ADD_TASK:
		
		default:
			//Take the "" keywords out
			userInput = transferQuoteToHashMap(PARAMETER.DESC,"do",userInput, keywordHash);
			userInput = transferQuoteToHashMap(PARAMETER.VENUE,"at",userInput, keywordHash);
			
			if(keywordHash.get(PARAMETER.DESC) == null){
				userInput = transferQuoteToHashMap(PARAMETER.DESC,"",userInput, keywordHash);
			}
			
			addAttributesWithoutKeyword(keywordsInInput, paramInInput, userInput.split(obtainDelimiterStringList(keywordsInInput)), keywordHash);
			
			if(keywordHash.get(PARAMETER.START_TIME) == null && keywordHash.get(PARAMETER.END_TIME) == null && keywordHash.get(PARAMETER.DEADLINE_TIME) == null){
				addAttributesWithOneParamKeyword(daysInInput, PARAMETER.DATE, userInput.split(obtainDelimiterStringList(daysInInput)), keywordHash);
			}
			
			break;
			
		}
	}

	private static void addAttributesFromList(String[] wordList, PARAMETER param, String userInput,
			HashMap<PARAMETER, String> keywordHash) {
		for (int i = 0; i < wordList.length;i++){
			if(userInput.toLowerCase().contains(wordList[i].toLowerCase())){
				keywordHash.put(param, "true");
			}
		}
	}

	/**
	 * Used to remove repeated words inside a string obtained from a hashmap
	 * @param param The parameter to be used in obtaining the words from hashmap
	 * @param keywordHash The hashmap to obtain the string from
	 */
	private static void removeRepeatedWordsParam(PARAMETER param, HashMap<PARAMETER, String> keywordHash) {
		String wordList = keywordHash.get(param);
		if(wordList != null && wordList.length() > 0){
			wordList.replaceAll("(\\b\\w+\\b) (?=.*\\b\\1\\b)", "");
			keywordHash.put(param, wordList);
		}
	}

	/**
	 * Places a matching string in the PARAMTER of keywordHash for a String in the keywords
	 * @param userInput The string to be parsed for keywords
	 * @param keywords The keywords each word in the userInput will be compared to
	 * @param paramEqv The corresponding string to be used for a found match
	 * @param paramToUse The parameter to store the paramEqv to 
	 * @param keywordHash The hashmap to obtain the paramToUse
	 */
	private static void addStringToParamFromList(String userInput, String[] keywords, String[] paramEqv,
			PARAMETER paramToUse, HashMap<PARAMETER, String> keywordHash) {
		for(int i = 0;i < keywords.length;i++){
			if(userInput.contains(keywords[i])){
				if(keywordHash.get(paramToUse) == null){
					keywordHash.put(paramToUse, paramEqv[i]);
				}
				else {
					keywordHash.put(paramToUse, keywordHash.get(paramToUse) + 
										" " + 
										paramEqv[i]);
				}
			}
		}
	}

	/**
	 * Obtains the words followed by a keyword that match a list of Strings
	 * @param inputString The String to parse
	 * @param startingPosition The starting position of the search
	 * @param offset The offset of the keyword used to delimit the string
	 * @param keywords the list of keywords to compare each trailing word to
	 * @param param The Parameter which each matching word will be added to
	 * @param keywordHash The hashmap containing the list of interest
	 * @return The original string with all the trailing words of the keyword that
	 * matched the keywords and the keyword itself
	 */
	private static String obtainTrailingKeywordsToHashmap(String inputString, int startingPosition, int offset, String[] keywords,
			PARAMETER param, HashMap<PARAMETER, String> keywordHash) {
		int endPosition = startingPosition + offset;
		String[] trimedKeywords = trimStringList(keywords);
		while(indexKeywordInString(nextWordFromIndex(inputString,endPosition),trimedKeywords) != PARAM_NOT_FOUND){
			if(keywordHash.get(param) == null){
				keywordHash.put(param, nextWordFromIndex(inputString,endPosition));
			}
			else {
				keywordHash.put(param, keywordHash.get(param) + 
									" " + 
									nextWordFromIndex(inputString,endPosition));
			}
			endPosition = endPosition +	nextWordFromIndex(inputString,endPosition).length() + 1;
		}
		if(endPosition == startingPosition + offset){
			return trimStringPortionOut(inputString, startingPosition, endPosition - 1);
		} else {
			return trimStringPortionOut(inputString, startingPosition, endPosition);
		}
		
	}

	/**
	 * Trims each word inside a list
	 * @param keywords The list to be trimmed
	 * @return keywords with all trimmed Strings
	 */
	private static String[] trimStringList(String[] keywords) {
		String[] trimedKeywords = new String[keywords.length];
		for(int i =0;i < keywords.length;i++){
			trimedKeywords[i] = keywords[i].trim();
		}
		return trimedKeywords;
	}

	/**
	 * used to obtain the index of the next word from a starting position
	 * @param inputString The string to traverse
	 * @param startingPostion The position to start from
	 * @return The index of the next word
	 */
	private static String nextWordFromIndex(String inputString, int startingPostion) {
		if(inputString.length()>startingPostion){
			String remainingString = inputString.substring(startingPostion);
			return remainingString.trim().split(" ")[0];
		}
		return null;
	}

	/**
	 * Obtains the delimiter string for an array of strings
	 * @param keywordsInInputAdd Array of strings to parse
	 * @return Delimiter string to use
	 */
	private static String obtainDelimiterStringList(String[] keywordsInInputAdd) {
		StringBuilder result = new StringBuilder();
		for(String s:keywordsInInputAdd){
			result.append("(?= \\b"+ s + ")|");
		}
		return result.deleteCharAt(result.length() - 1).toString();
	}

	/**
	 * Used to obtain the taskID from a string and return the rest of the sentence
	 * This can be used with a single ID or a string following it
	 * @param userInput The user input
	 * @param keywordHash 
	 * @return The string after the ID has been taken out
	 */
	private static void getTaskID(String userInput, HashMap<PARAMETER, String> keywordHash) {
		String[] inputArray = userInput.trim().split(SPACE_CHARACTER,2);
		if(inputArray[0].toLowerCase().equals("all")){
			keywordHash.put(PARAMETER.TASKID, ALL_TASKS);
		} else if(inputArray[0] == null || !containsOnlyPositiveNumbers(inputArray[0])){
			// To prevent null exceptions in TaskHandler
			keywordHash.put(PARAMETER.TASKID, "-1");
		} else {
			keywordHash.put(PARAMETER.TASKID, inputArray[0]);
		}
	}
	
	/**
	 * Used to check if the contents of a string are numerical
	 * @param numString The string to be checked for all numbers
	 * @return A boolean representation of whether the string provided is all numbers
	 */
	private static boolean containsOnlyPositiveNumbers(String numString) {
		return numString.matches("^[0-9 ]+$");
	}

	/**
	 * Searches, adds to hashmap and removes a keyword and its quote parameter
	 * @param keyword The parameter to be placed in the hashmap
	 * @param keywordString the keyword to be looked for
	 * @param userInput The full string that is being trimmed
	 * @param keywordHash 
	 * @return The trimmed string without the 
	 */
	private static String transferQuoteToHashMap(PARAMETER keyword,String keywordString, String userInput, HashMap<PARAMETER, String> keywordHash) {
		int positionOfKeyword = findKeywordIndexInput(userInput, keywordString,0);
		if(positionOfKeyword == PARAM_NOT_FOUND){
			return userInput;
		}
		int startOfQuote = userInput.indexOf(QUOTE_INTEGER, positionOfKeyword);
		int endOfQuote = userInput.indexOf(QUOTE_INTEGER, startOfQuote + 1);
		if(startOfQuote >= 0 && endOfQuote > 0){
			keywordHash.put(keyword, (getKeywordInString(userInput, startOfQuote + 1, endOfQuote - 1))); //Ignore the quote delimeters
			return trimStringPortionOut(userInput, positionOfKeyword, endOfQuote).trim();
		} else{
			return userInput;
		}
		
	}

	/**
	 * Finds a keyword index that is not within quotes
	 * @param userInput The string that is searched for the keyword
	 * @param keywordString The keyword to be searched
	 * @return The index of the keyword found
	 */
	private static int findKeywordIndexInput(String userInput, String keywordString, int StartIndex) {
		boolean outsideOfQuotes = true;
		if(userInput == null || userInput.length() == 0){
			return -1;
		} else if(keywordString == null || keywordString.length()==0){
			return 0;
		}
		char[] keyword = keywordString.toCharArray();
		int indexInKeyword = 0;
		char[] userInputCharArr = userInput.toCharArray();
		if(StartIndex < 0){
			StartIndex = 0;
		}
		for (int c = StartIndex; c < userInputCharArr.length;c++) {
			if(userInputCharArr[c] == QUOTE_INTEGER){
				outsideOfQuotes = !outsideOfQuotes;
			}
	        if(outsideOfQuotes && keyword[indexInKeyword] == userInputCharArr[c]){
	        	
	        	if(indexInKeyword >= keyword.length - 1){
	        		return c - indexInKeyword;
	        	}
	        	indexInKeyword++;
	        } else {
	        	indexInKeyword = 0;
	        }
	    }
		return -1;
	}

	/**
	 * Used to trim a part inside of a String out
	 * @param userInput The string to be trimmed
	 * @param startOfDesc The start index of the portion to be trimmed out
	 * @param endOfDesc The end index of the portion to be trimmed out
	 * @return The trimmed out string result
	 */
	private static String trimStringPortionOut(String userInput, int startOfDesc, int endOfDesc) {
		StringBuilder result = new StringBuilder();
		if(userInput == null){
			return null;
		}
		char[] userInputCharArr = userInput.toCharArray();
	    for (int c = 0; c < userInputCharArr.length; c++) {
	        if (c < startOfDesc || c > endOfDesc) {
	            result.append(userInputCharArr[c]);
	        }
	    }
	    return result.toString();
	}

	/**
	 * Used to obtain a string inside a String
	 * @param userInput The string to be trimmed
	 * @param startOfDesc The start index of the portion to be trimmed out
	 * @param endOfDesc The end index of the portion to be trimmed out
	 * @return The string inside the indexes of the userInput
	 */
	private static String getKeywordInString(String userInput, int startOfDesc, int endOfDesc) {
		StringBuilder result = new StringBuilder();
		if(userInput == null){
			return null;
		}
		char[] userInputCharArr = userInput.toCharArray();
	    for (int c = 0; c < userInputCharArr.length; c++) {
	        if (c >= startOfDesc && c <= endOfDesc) {
	            result.append(userInputCharArr[c]);
	        }
	    }
	    return result.toString();
	}

	/**
	 * return the index of a word without minding the case of the letters
	 * @param input The input string to be searched
	 * @param keywordsInInput The keyword list to compare to the input
	 * @return The index of the keyword input matches
	 */
	private static int indexKeywordInString(String input, String[] keywordsInInput) {
		if(input != null && keywordsInInput != null){
			for(int i = 0;i< keywordsInInput.length;i++){
			   if(input.toLowerCase().contains(keywordsInInput[i])){
				   return i;
			   }
			}
		}
		return PARAM_NOT_FOUND;
	}
	
	/**
	 * Wrapper for a single parameter to be inserted for multiple words
	 * @param keywordsInInput The keyword list corresponding to the parameters
	 * @param paramInInputs The parameter list corresponding to the keywords
	 * @param stringsToParse The strings that need to be placed in the appropriate parameters
	 * @param keywordHash The hashtable to be updated
	 */
	private static void addAttributesWithOneParamKeyword(String[] keywordsInInput, PARAMETER paramInInput, String[] stringsToParse,
			HashMap<PARAMETER, String> keywordHash) {
		PARAMETER[] paramInInputs = new PARAMETER[keywordsInInput.length];
		for(int i =0; i < keywordsInInput.length;i++){
			paramInInputs[i] = paramInInput;
		}
		addAttributesWithKeyword(keywordsInInput,paramInInputs,stringsToParse,keywordHash);
	}
	
	/**
	 * Takes every sentence and extracts the keyword, then takes the string and places
	 * it in the appropriate parameter
	 * @param keywordsInInput The keyword list corresponding to the parameters
	 * @param paramInInputs The parameter list corresponding to the keywords
	 * @param stringsToParse The strings that need to be placed in the appropriate parameters
	 * @param keywordHash The hashtable to be updated
	 */
	private static void addAttributesWithKeyword(String[] keywordsInInput,PARAMETER[] paramInInputs, String[] stringsToParse, HashMap<PARAMETER, String> keywordHash) {
		//Traverses the string word by word
		for(int currentPhrase = 0; currentPhrase < stringsToParse.length; currentPhrase++){
			int commandFromKeywordIndex = indexKeywordInString(stringsToParse[currentPhrase], keywordsInInput);
			if(commandFromKeywordIndex != PARAM_NOT_FOUND && keywordHash.get(paramInInputs[commandFromKeywordIndex]) ==  null){
				keywordHash.put(paramInInputs[commandFromKeywordIndex], stringsToParse[currentPhrase].trim());
			}
		}
	}	

	/**
	 * Takes every sentence and extracts the keyword, then takes the string and places
	 * it in the appropriate parameter
	 * @param keywordsInInput The keyword list corresponding to the parameters
	 * @param paramInInputs The parameter list corresponding to the keywords
	 * @param stringsToParse The strings that need to be placed in the appropriate parameters
	 * @param keywordHash The hashtable to be updated
	 */
	private static void addAttributesWithoutKeyword(String[] keywordsInInput,PARAMETER[] paramInInputs, String[] stringsToParse, HashMap<PARAMETER, String> keywordHash) {
		//Traverses the string word by word
		for(int currentPhrase = 0; currentPhrase < stringsToParse.length; currentPhrase++){
			int commandFromKeywordIndex = indexKeywordInString(stringsToParse[currentPhrase], keywordsInInput);
			if(commandFromKeywordIndex != PARAM_NOT_FOUND && keywordHash.get(paramInInputs[commandFromKeywordIndex]) ==  null){
				keywordHash.put(paramInInputs[commandFromKeywordIndex], stringsToParse[currentPhrase].split(keywordsInInput[commandFromKeywordIndex])[1].trim()); //Ignore the quote delimeters
			}
		}
	}
}
```
###### Task\TaskHandler.java
``` java
	 * Returns a task with taskID if found, null otherwise
	 * @param taskId
	 * @return Task or null
	 */
	public static Task getTask(int taskID){
		for(int i = 0; i < taskList.size(); i++){
			if(taskList.get(i).getTaskId() == taskID){
				return taskList.get(i);
			}
		}
		return null;
	}
	
	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param parsedParamTable
	 * @return
	 */
	public static ArrayList<Task> searchTasks(HashMap<PARAMETER, Object> parsedParamTable){
		ArrayList<Task> searchResult = new ArrayList<Task>(50);
		Task compareTask = null;
		
		Boolean _isDone = null;
		Boolean _isPast = null;
		Boolean _hasEnded = null;
		
		if(!isDisplayAll(parsedParamTable)){
			_isDone 	= (parsedParamTable.get(PARAMETER.IS_DONE) != null)   ? 
					(Boolean)parsedParamTable.get(PARAMETER.IS_DONE) 	: false;
			_isPast 	= (Boolean)parsedParamTable.get(PARAMETER.IS_PAST);
			_hasEnded 	= (Boolean)parsedParamTable.get(PARAMETER.HAS_ENDED);
		}
		
		compareTask = new Task((int)parsedParamTable.get(PARAMETER.TASKID),
				(String)parsedParamTable.get(PARAMETER.DESC),
				(String)parsedParamTable.get(PARAMETER.VENUE), 
				(Date)parsedParamTable.get(PARAMETER.START_DATE),
				(Date)parsedParamTable.get(PARAMETER.END_DATE), 
				(Date)parsedParamTable.get(PARAMETER.DEADLINE_DATE),
				_isDone,
				_isPast,
				_hasEnded);
		
		for (Task t : taskList) {
			if (isTaskSameFields(compareTask, t)) {
				searchResult.add(t);
			}
		}
		return sortTasks(searchResult);
	}

	private static boolean isDisplayAll(HashMap<PARAMETER, Object> parsedParamTable) {
		return parsedParamTable.get(PARAMETER.SPECIAL) != null && (boolean)parsedParamTable.get(PARAMETER.SPECIAL);
	}
	
	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param searchResult
	 * @return
	 */
	private static ArrayList<Task> sortTasks(ArrayList<Task> searchResult) {
		ArrayList<Task> periodsAndDeadlines = new ArrayList<>();
		ArrayList<Task> floating = new ArrayList<>();
		
		ArrayList<Task> result = new ArrayList<>();
		
		for(Task t:searchResult){
			if((t.getStartDateTime() != null && t.getEndDateTime() != null) || t.getDeadline() != null){
				periodsAndDeadlines.add(t);
			} else {
				floating.add(t);
			}
		}
		
		bubbleSortTasks(periodsAndDeadlines,containsEarlierThanToday(periodsAndDeadlines));
		
		result.addAll(periodsAndDeadlines);
		result.addAll(floating);
		
		return result;
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param periodsAndDeadlines
	 * @return
	 */
	private static boolean containsEarlierThanToday(ArrayList<Task> periodsAndDeadlines) {
		for(Task t :periodsAndDeadlines){
			if((t.getDeadline() != null && t.getDeadline().before(new Date())) || 
					(t.getStartDateTime() != null && t.getStartDateTime().before(new Date()))){
				return true;
			}
		}
		return false;
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param taskListToSort
	 */
	private static void bubbleSortTasks(ArrayList<Task> taskListToSort, boolean isSortAsending) {
		for (int i=0; i < taskListToSort.size() - 1;i++)
	    {
	        if(isPeriodDeadlineComp(taskListToSort.get(i),taskListToSort.get(i+1),isSortAsending))
	        {
	        	sendToEndOfList(taskListToSort, i);
	            bubbleSortTasks(taskListToSort,isSortAsending);
	        }
	    }
		
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param firstTask
	 * @param secondTask
	 * @return
	 */
	private static boolean isPeriodDeadlineComp(Task firstTask, Task secondTask, boolean isSortAsending) {
		
		Date compDateOne = deadlineOrPeriodDate(firstTask);
		Date compDateTwo = deadlineOrPeriodDate(secondTask);
		if(isSortAsending){
			return compDateOne.after(compDateTwo);
		} else {
			return compDateOne.before(compDateTwo);
		}
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param firstTask
	 * @return
	 */
	private static Date deadlineOrPeriodDate(Task firstTask) {
		if(firstTask.getDeadline() != null){
			return firstTask.getDeadline();
		} else {
			return firstTask.getStartDateTime();
		}
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param tasklist
	 * @param i
	 */
	private static void sendToEndOfList(ArrayList<Task> tasklist, int i) {
		tasklist.add(tasklist.get(i));
		tasklist.remove(i);
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isTaskSameFields(Task compareTask, Task taskListTask) {
		if (compareTask.getDeadline() != null) {
			calendar.setTime(compareTask.getDeadline());
		} else {
			// do nothing, calendar displays current time by default
		}
		calendar.set(Calendar.DAY_OF_YEAR, calendar.get(Calendar.DAY_OF_YEAR)-7);	// One week earlier

		return
			isSameTaskId(compareTask, taskListTask)				&&
			isBeforeDateTime(compareTask, taskListTask)			&&
			isAfterDateTime(compareTask, taskListTask)			&&
			isAfterDeadline(compareTask, taskListTask)			&&
			containsWithinVenue(compareTask, taskListTask)		&&
			containsWithinDescription(compareTask, taskListTask)&&
			isSameLogic(compareTask.isDone(), 
					taskListTask.isDone()) 						&&
			isSameLogic(compareTask.isPastDeadline(), 
					taskListTask.isPastDeadline()) 				&&
			isSameLogic(compareTask.isHasEnded(), 
					taskListTask.isHasEnded()) 					&&
			
			(!compareTask.isEmpty()															
					
			);
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isSameLogic(Boolean compareTask, Boolean taskListTask) {
		return compareTask == null || compareTask == taskListTask;
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isAfterDeadline(Task compareTask, Task taskListTask) {
		return compareTask.getDeadline() 		== null	|| (taskListTask.getDeadline() != null 	    &&
			compareTask.getDeadline().after(taskListTask.getDeadline()) 							&& 
			(taskListTask.getDeadline().after(calendar.getTime())));
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean containsWithinDescription(Task compareTask, Task taskListTask) {
		return compareTask.getDescription()	== null || (taskListTask.getDescription() != null 		&&
				taskListTask.getDescription().toLowerCase().contains(
						compareTask.getDescription().toLowerCase()));
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean containsWithinVenue(Task compareTask, Task taskListTask) {
		return compareTask.getVenue()			== null || (taskListTask.getVenue() != null 	    &&
				taskListTask.getVenue().toLowerCase().contains(compareTask.getVenue().toLowerCase())									);
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isAfterDateTime(Task compareTask, Task taskListTask) {
		return compareTask.getEndDateTime()	== null	|| (taskListTask.getEndDateTime() != null   	&&
			compareTask.getEndDateTime().after(taskListTask.getStartDateTime()));
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isBeforeDateTime(Task compareTask, Task taskListTask) {
		return compareTask.getStartDateTime()	== null	|| (taskListTask.getStartDateTime() != null &&
			compareTask.getStartDateTime().before(taskListTask.getEndDateTime()));
	}

	/**
```
###### Task\TaskHandler.java
``` java
	 * 
	 * @param compareTask
	 * @param taskListTask
	 * @return
	 */
	private static boolean isSameTaskId(Task compareTask, Task taskListTask) {
		return compareTask.getTaskId()		== -1 	|| compareTask.getTaskId()		== ALL_TASKS ||
			compareTask.getTaskId() == taskListTask.getTaskId();
	}
	
	/** 
```
###### Task\TaskListEdit.java
``` java
	 */
	public TaskListEdit(Task task, ArrayList<Task> _taskList, int _oldCurrentId, int _newCurrentId,boolean _isAdd) {
		super();
		taskList = _taskList;
		taskListContents = new ArrayList<Task>();
		taskListContents.addAll(taskList);
		if(!_isAdd){
			taskListContents.add(task);
		}
		newCurrentId = _newCurrentId;
		oldCurrentId = _oldCurrentId;
		isAdd = _isAdd;
	}
	
	/**
```
###### Task\TaskListEdit.java
``` java
	 */
	public TaskListEdit(ArrayList<Task> _taskList, int _oldCurrentId, int _newCurrentId,boolean _isAdd) {
		super();
		taskList = _taskList;
		taskListContents = new ArrayList<Task>();
		taskListContents.addAll(taskList);
		newCurrentId = _newCurrentId;
		oldCurrentId = _oldCurrentId;
		isAdd = _isAdd;
	}

	@Override
	public String getUndoPresentationName() {
		return "Undo add task.";
	}
	
	@Override
	public String getRedoPresentationName() {
		return "Redo add task.";
	}
	
	/**
```
###### Task\TaskListEdit.java
``` java
	 */
	@Override
	public void undo() {
		super.undo();
		ArrayList<Task> tempTasklist = new ArrayList<Task>(taskList);
		if(isAdd){
			for(Iterator<Task> iterator = taskList.iterator(); iterator.hasNext();){
				Task k = iterator.next();
				if(!taskListContents.contains(k)){
					iterator.remove();
				}
			}
		} else {
			for(Task k:taskListContents){
				if(!taskList.contains(k)){
					taskList.add(k);
				}
			}
			
		}
		
		taskListContents = new ArrayList<Task>(tempTasklist);
		TaskHandler.setCurrentTaskId(oldCurrentId);
	}
	
	/**
```
###### Task\TaskListEdit.java
``` java
	 */
	@Override
	public void redo() {
		super.redo();
		ArrayList<Task> tempTasklist = new ArrayList<Task>(taskList);
		if(!isAdd){
			for(Iterator<Task> iterator = taskList.iterator(); iterator.hasNext();){
				Task k = iterator.next();
				if(!taskListContents.contains(k)){
					iterator.remove();
				}
			}
		} else {
			for(Task k:taskListContents){
				if(!taskList.contains(k)){
					taskList.add(k);
				}
			}
			
		}
		
		taskListContents = new ArrayList<Task>(tempTasklist);
		TaskHandler.setCurrentTaskId(oldCurrentId);
	}
}
```
###### Task\Validator.java
``` java
	 * 
	 *          Used to set the flag a Boolean flag in the hashmap
	 * @param hashmap
	 * @param isDone
	 * @param objectHashMap
	 */
	private static void setFlag(HashMap<PARAMETER, String> hashmap, PARAMETER param,
			HashMap<PARAMETER, Object> objectHashMap) {
		if (hashmap.get(param) != null) {
			objectHashMap.put(param, hashmap.get(param).equals(TRUE_STRING));
		}
	}

	/**
```
###### test\EditTests.java
``` java
 */
package test;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import Task.Period;
import Task.Task;
import Task.TaskDeadlineEdit;
import Task.TaskDescEdit;
import Task.TaskDoneEdit;
import Task.TaskListEdit;
import Task.TaskPeriodEdit;
import Task.TaskVenueEdit;

public class EditTests {
	
	Task task = new Task(1,"Description",null,"Venue");

	//DEADLINE EDIT//
	@Test
	public void taskDeadlineTest() {
		Date deadlineDate = new Date();
		task.setDeadline(deadlineDate);
		
		TaskDeadlineEdit edit = new TaskDeadlineEdit(task, null, deadlineDate);
		
		assertEquals(deadlineDate,
				task.getDeadline());
		
		//UNDO
		edit.undo();
		
		assertEquals(null,
				task.getDeadline());
		
		//REDO
		edit.redo();
		
		assertEquals(deadlineDate,
				task.getDeadline());		
		
	}
	
	//PERIOD EDIT//
	@Test
	public void taskPeriodEditTest() {
		Date startTime = new Date();
		Date endTime = new Date();
		Period period = new Period(startTime, endTime);
		
		task.setPeriod(period);
		
		TaskPeriodEdit edit = new TaskPeriodEdit(task, null, period);
		
		assertEquals(period,
				task.getPeriod());
		
		//UNDO
		edit.undo();
		
		assertEquals(null,
				task.getPeriod());
		
		//REDO
		edit.redo();
		
		assertEquals(period,
				task.getPeriod());
		
	}
	
	//DESC EDIT//
	@Test
	public void taskDescEditTest() {
		
		String description = "Sample Description";
		
		task.setDescription(description);
		
		TaskDescEdit edit = new TaskDescEdit(task, null,description);
		
		assertEquals(description,
				task.getDescription());
		
		//UNDO
		edit.undo();
		
		assertEquals(null,
				task.getDescription());
		
		//REDO
		edit.redo();
		
		assertEquals(description,
				task.getDescription());
		
	}
	
	//VENUE EDIT//
	@Test
	public void taskVenueEditTest() {
		
		String venue = "Sample Description";
		
		task.setVenue(venue);
		
		TaskVenueEdit edit = new TaskVenueEdit(task, null,venue);
		
		assertEquals(venue,
				task.getVenue());
		
		//UNDO
		edit.undo();
		
		assertEquals(null,
				task.getVenue());
		
		//REDO
		edit.redo();
		
		assertEquals(venue,
				task.getVenue());
		
	}
	
	//DONE EDIT//
	@Test
	public void taskDoneEditTest() {
		
		boolean done = true;
		
		task.setDone(done);
		
		TaskDoneEdit edit = new TaskDoneEdit(task, !done, done);
		
		assertEquals(done,
				task.isDone());
		
		//UNDO
		edit.undo();
		
		assertEquals(!done,
				task.isDone());
		
		//REDO
		edit.redo();
		
		assertEquals(done,
				task.isDone());
		
	}
	
	//TASKLIST EDIT//
	@Test
	public void taskListEditTest() {
		
		boolean isAnAdd = true;
		
		ArrayList<Task> taskList = new ArrayList<Task>();
		taskList.add(task);
		Task task2 = new Task(2,"Description2",null,"Venue2");
		taskList.add(task2);
		Task task3 = new Task(3,"Description3",null,"Venue3");
		taskList.add(task3);
		Task task4 = new Task(4,"Description4",null,"Venue4");
		taskList.add(task4);
		Task task5 = new Task(5,"Description5",null,"Venue5");
		
		TaskListEdit edit     = new TaskListEdit(task5, taskList, 5, 6,isAnAdd);
		
		taskList.add(task5);
		
		assertEquals(5,
				taskList.size());
		
		//UNDO ONE
		edit.undo();
		
		assertEquals(4,
				taskList.size());
		
		//REDO ONE
		edit.redo();
		
		assertEquals(5,
				taskList.size());
		
		//UNDO MULTIPLE
		edit     = new TaskListEdit(taskList, 6, 6,false);
		while(taskList.size() != 0){
			task = taskList.get(0);
			taskList.remove(task);
		}
		
		assertEquals(0,
				taskList.size());
		
		edit.undo();
		
		assertEquals(5,
				taskList.size());
		
		//REDO MULTIPLE
		edit.redo();
		
		assertEquals(0,
				taskList.size());
		
	}
	
	//COMPOUNDED EDIT//
	//TESTED THOUGH TASK HANDLER

}
```
###### test\StringParserTest.java
``` java
 *  
 *  Represents the test for the String Parser class
 * 
 */

package test;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.util.HashMap;

import org.junit.Test;

import Task.StringParser;
import Task.COMMAND_TYPE;
import Task.PARAMETER;

public class StringParserTest {

	private HashMap<PARAMETER, String> keywordHash =  new HashMap<PARAMETER, String>(0);
	
	@Test
	public void testObtainStringHashMap() throws ParseException {
		
		//Empty Case
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"",keywordHash);
		assertEquals(0,
				keywordHash.size());
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Basic case
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"by 12/11 1100 at \"hong kong\" do \"to be or not\" ",keywordHash);
		
		assertEquals("to be or not",
				keywordHash.get(PARAMETER.DESC));
		assertEquals("hong kong",
				keywordHash.get(PARAMETER.VENUE));
		assertEquals("12/11 1100",
				keywordHash.get(PARAMETER.DEADLINE_TIME));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Having same day scheduling
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"at \"hong kong\" do \"to be or not\" on 15/11 from 1100 to 1500",keywordHash);
		
		assertEquals("15/11",
				keywordHash.get(PARAMETER.DATE));
		assertEquals("1500",
				keywordHash.get(PARAMETER.END_TIME));
		assertEquals("1100",
				keywordHash.get(PARAMETER.START_TIME));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Having same day scheduling
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"from 1100 at \"hong kong\" to 1500 do \"to be or not\" on 15/11",keywordHash);
		
		assertEquals("15/11",
				keywordHash.get(PARAMETER.DATE));
		assertEquals("1500",
				keywordHash.get(PARAMETER.END_TIME));
		assertEquals("1100",
				keywordHash.get(PARAMETER.START_TIME));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Using today keyword
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"at \"hong kong\" do \"to be or not\" today",keywordHash);
		
		assertEquals("today",
				keywordHash.get(PARAMETER.DATE));
		
		//Using tomorrow keyword
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"at \"hong kong\" tomorrow 5pm do \"to be or not\"",keywordHash);
		
		assertEquals("tomorrow 5pm",
				keywordHash.get(PARAMETER.DATE));
		
		//Using tmr keyword
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.ADD_TASK,
				"at \"hong kong\" tmr 5pm do \"to be or not\"",keywordHash);
		
		assertEquals("tmr 5pm",
				keywordHash.get(PARAMETER.DATE));
		
		//Use no keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.EDIT_TASK,
				"at \"hong kong\" tmr 5pm do \"to be or not\" no from",keywordHash);
		
		assertEquals("from",
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		//Use no keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.EDIT_TASK,
				"at \"hong kong\" tmr 5pm do \"to be or not\" deadline",keywordHash);
		
		assertEquals("from to",
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		//Use week keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.EDIT_TASK,
				"at \"hong kong\" on next week do \"to be or not\" deadline",keywordHash);
		
		assertEquals("next week  deadline",
				keywordHash.get(PARAMETER.DATE));
		
		//Use month keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.EDIT_TASK,
				"at \"hong kong\" on next month do \"to be or not\" deadline",keywordHash);
		
		assertEquals("next month  deadline",
				keywordHash.get(PARAMETER.DATE));
		
		//Use done keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				"at \"hong kong\" on next month do \"to be or not\" deadline done",keywordHash);
		
		assertEquals("true",
				keywordHash.get(PARAMETER.IS_DONE));
		//Use done keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				"at \"hong kong\" ended on next month do \"to be or not\" deadline",keywordHash);
		
		assertEquals("true",
				keywordHash.get(PARAMETER.HAS_ENDED));
		
		//Use done keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				"at \"hong kong\" on next month past do \"to be or not\" deadline",keywordHash);
		
		assertEquals("true",
				keywordHash.get(PARAMETER.IS_PAST));
		
		//Use all keyword
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				"all at \"hong kong\" on next month do \"to be or not\" deadline",keywordHash);
		
		assertEquals("true",
				keywordHash.get(PARAMETER.SPECIAL));
	}
	
	@Test
	public void testEditobtainStringHashMap() throws ParseException {
		
		//Basic case
		StringParser.getStringHashMap(COMMAND_TYPE.EDIT_TASK,
				"4 by 12/11 1100 at \"hong kong\" do \"to be or not\" ",keywordHash);
		assertEquals("4",
				keywordHash.get(PARAMETER.TASKID));
		assertEquals("to be or not",
				keywordHash.get(PARAMETER.DESC));
		assertEquals("hong kong",
				keywordHash.get(PARAMETER.VENUE));
		assertEquals("12/11 1100",
				keywordHash.get(PARAMETER.DEADLINE_TIME));
	}
	
	@Test
	public void testDisplayobtainStringHashMap() throws ParseException {
		//Empty Case
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				"",keywordHash);
		assertEquals(1,
				keywordHash.size());
		
		//Basic case
		
		StringParser.getStringHashMap(COMMAND_TYPE.DISPLAY,
				" 4",keywordHash);
		assertEquals("4",
				keywordHash.get(PARAMETER.TASKID));
	}
	
	@Test
	public void testDeleteStringHashMap() throws ParseException {
		//Empty Case
		StringParser.getStringHashMap(COMMAND_TYPE.DELETE_TASK,
				"",keywordHash);
		assertEquals(1,
				keywordHash.size());
		
		//Basic case
		StringParser.getStringHashMap(COMMAND_TYPE.DELETE_TASK,
				"10",keywordHash);
		assertEquals("10",
				keywordHash.get(PARAMETER.TASKID));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Basic case space before
		
		StringParser.getStringHashMap(COMMAND_TYPE.DELETE_TASK,
				" 10",keywordHash);
		assertEquals("10",
				keywordHash.get(PARAMETER.TASKID));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Basic case space after
		
		StringParser.getStringHashMap(COMMAND_TYPE.DELETE_TASK,
				"10 ",keywordHash);
		assertEquals("10",
				keywordHash.get(PARAMETER.TASKID));
		
		//All case space after
		
		StringParser.getStringHashMap(COMMAND_TYPE.DELETE_TASK,
				" all ",keywordHash);
		assertEquals("-2",
				keywordHash.get(PARAMETER.TASKID));
	}
	
	// NORMALLY PRIVATE METHOD TESTING //
	/*
	@Test
	public void testTransferQuoteToHashMap() throws ParseException {
		
		keywordHash =  new HashMap<PARAMETER, String>(0); //Initialize
		
		//Basic case do
		assertEquals("at \"hong kong\" by 12/11 1100",
						StringParser.transferQuoteToHashMap(PARAMETER.DESC,"do",
								"do \"to be or not\" at \"hong kong\" by 12/11 1100", keywordHash));
		
		assertEquals("to be or not",
				keywordHash.get(PARAMETER.DESC));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Basic case at
		
		assertEquals("by 12/11 1100",
						StringParser.transferQuoteToHashMap(PARAMETER.VENUE,"at",
								" at \"hong kong\" by 12/11 1100", keywordHash));
		
		assertEquals("hong kong",
						keywordHash.get(PARAMETER.VENUE));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//No space in between quotes
		
		assertEquals("by 12/11 1100",
						StringParser.transferQuoteToHashMap(PARAMETER.VENUE,"at",
								"at\"hong kong\"by 12/11 1100", keywordHash));
		
		assertEquals("hong kong",
						keywordHash.get(PARAMETER.VENUE));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//at beginning
		assertEquals("by 12/11 1100",
						StringParser.transferQuoteToHashMap(PARAMETER.DESC,"",
								"\"do sth\" by 12/11 1100", keywordHash));
		assertEquals("do sth",
				keywordHash.get(PARAMETER.DESC));
	}
	
	@Test
	public void testObtainTrailingKeywordsToHashmap(){
		
		String[] 	keywordsInInput		={"on","from","to","by","do","at"};
		
		keywordHash =  new HashMap<PARAMETER, String>(0); //Initialize
		
		//Basic case no
		assertEquals("at \"hong kong\" by 12/11 1100 ",
						StringParser.obtainTrailingKeywordsToHashmap("at \"hong kong\" by 12/11 1100 no from",
						29,"no ".length(),keywordsInInput,PARAMETER.DELETE_PARAMS, keywordHash));
		
		assertEquals("from",
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Many case no
		assertEquals("at \"hong kong\" by 12/11 1100 ",
						StringParser.obtainTrailingKeywordsToHashmap("at \"hong kong\" by 12/11 1100 no from by at",
						29,"no ".length(),keywordsInInput,PARAMETER.DELETE_PARAMS, keywordHash));
		
		assertEquals("from by at",
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//Not recognized case
		assertEquals("at \"hong kong\" by 12/11 1100 buy from",
						StringParser.obtainTrailingKeywordsToHashmap("at \"hong kong\" by 12/11 1100 no buy from",
						29,"no ".length(),keywordsInInput,PARAMETER.DELETE_PARAMS, keywordHash));
		
		assertEquals(null,
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
		
		//no with no keywords
		assertEquals("at \"hong kong\" by 12/11 1100 ",
						StringParser.obtainTrailingKeywordsToHashmap("at \"hong kong\" by 12/11 1100 no ",
						29,"no ".length(),keywordsInInput,PARAMETER.DELETE_PARAMS, keywordHash));
		
		assertEquals(null,
				keywordHash.get(PARAMETER.DELETE_PARAMS));
		
		keywordHash =  new HashMap<PARAMETER, String>(0);
	}

	@Test
	public void testFindKeywordIndexInput() {
		
		assertEquals(3,StringParser.findKeywordIndexInput("   hello","hello",-5));
		assertEquals(3,StringParser.findKeywordIndexInput("   hello","hello",0));
		assertEquals(-1,StringParser.findKeywordIndexInput("he\"llo\"","hello",0));
		assertEquals(-1,StringParser.findKeywordIndexInput("\"hello\"","hello",0));
		assertEquals(7,StringParser.findKeywordIndexInput("\"hello\"hello","hello",0));
		assertEquals(0,StringParser.findKeywordIndexInput("on 15/11 from 1100 to 1500","on",0));
		assertEquals(11,StringParser.findKeywordIndexInput("by 11/12   #hello","#",0));
		assertEquals(18,StringParser.findKeywordIndexInput("by 11/12   #hello #waffles","#",16));
		assertEquals(0,StringParser.findKeywordIndexInput("   #hello","",0));
		assertEquals(-1,StringParser.findKeywordIndexInput(null,"",0));
		assertEquals(0,StringParser.findKeywordIndexInput("   #hello",null,0));
		
	}

	@Test
	public void testTrimStringPortionOut() {
		
		assertEquals("",StringParser.trimStringPortionOut("hello",0,5));
		assertEquals("",StringParser.trimStringPortionOut("hello",-1,7));
		assertEquals("hello",StringParser.trimStringPortionOut("hello",7,9));
		assertEquals("ho",StringParser.trimStringPortionOut("hello",1,3));
		assertEquals("",StringParser.trimStringPortionOut("",1,3));
		assertEquals(null,StringParser.trimStringPortionOut(null,1,3));
	}

	@Test
	public void testGetKeywordnInString() {
		
		assertEquals("hello",StringParser.getKeywordInString("hello",0,5));
		assertEquals("hello",StringParser.getKeywordInString("hello",-1,7));
		assertEquals("",StringParser.getKeywordInString("hello",7,9));
		assertEquals("ell",StringParser.getKeywordInString("hello",1,3));
		assertEquals("",StringParser.getKeywordInString("",1,3));
		assertEquals(null,StringParser.getKeywordInString(null,1,3));
	}

	@Test
	public void testStringCompareToList() {
		
		assertEquals(2,StringParser.indexKeywordInString("hello",new String[]{"tiger","heelo","hell"}));
		assertEquals(1,StringParser.indexKeywordInString("hello",new String[]{"tiger","hello","hell"}));
		assertEquals(2,StringParser.indexKeywordInString("hello",new String[]{"tiger","hello2","hell"}));
		assertEquals(-1,StringParser.indexKeywordInString("",new String[]{"tiger","hello2","hell"}));
		assertEquals(-1,StringParser.indexKeywordInString("hello",new String[]{}));
		assertEquals(-1,StringParser.indexKeywordInString("hello",null));
		assertEquals(-1,StringParser.indexKeywordInString(null,null));
		
	}

	@Test
	public void testNextWordFromIndex() {
		
		assertEquals("hello",StringParser.nextWordFromIndex("hello me mine",0));
		assertEquals("ello",StringParser.nextWordFromIndex("hello me mine",1));
		assertEquals("me",StringParser.nextWordFromIndex("hello me mine",5));
		assertEquals("mine",StringParser.nextWordFromIndex("hello me mine",9));
		assertEquals(null,StringParser.nextWordFromIndex("",0));
		
	}
	*/
}
```
###### test\TaskHandlerTest.java
``` java
 */
import static org.junit.Assert.*;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import Task.*;
import java.util.ArrayList;
import java.io.File;
import java.util.Date;
import java.util.HashMap;
import java.text.SimpleDateFormat;

public class TaskHandlerTest {
	
	private static String DEFAULT_DATE;
	
	// Define success messages here
	private static String MESSAGE_WELCOME        ="Welcome to TaskBuddy!";
	private static String MESSAGE_PATH		   ="Your new path is: %s";
	private static String MESSAGE_SAVE		   ="Your calendar has been saved to %s!";
	private static String MESSAGE_OPEN		   ="Opening calendar at path %s";
	private static String MESSAGE_ADD_TASK       ="Successfully added task.";
	private static String MESSAGE_GET_TASK       ="Task %d returned";
	private static String MESSAGE_DISPLAY_ALL    ="All tasks displayed.";
	private static String MESSAGE_DISPLAY		   ="Search results:";
	private static String MESSAGE_SEARCH_TASK    ="Here are tasks matching your keywords:";
	private static String MESSAGE_DELETE_TASK    ="Task %d has been deleted";
	private static String MESSAGE_EDIT_TASK      ="Task %d has been updated!";
	private static String MESSAGE_UNDO_TASK      ="Successfully undoed change(s) to Task %d.";
	private static String MESSAGE_REDO_TASK      ="Successfully redoed change(s) to Task %d.";
	private static String MESSAGE_DONE_TASK      ="Successfully updated Task %d to completed.";
	private static String MESSAGE_UNDONE_TASK    ="Successfully updated Task %d to uncompleted.";
	private static String MESSAGE_EXIT           ="Thanks for using TaskBuddy! Changes saved to disk.";
	
	/** 
	 * Define warning messages here
	 * Warnings are less severe than errors.
	 * To communicate to the user they may have done something unintentional
	 */
	private static String WARNING_DEADLINE_BEFORE_NOW ="WARNING: You have specified a deadline that is before the current time";
	private static String WARNING_TASK_NOT_EDITED     ="Task %d was not edited.";

	// Define error messages here
	private static String ERROR_INVALID_COMMAND  ="Invalid Command.";
	private static String ERROR_EMPTY_TASKLIST   ="You have no tasks!";
	private static String ERROR_TASK_NOT_FOUND   ="The task was not found!";
	private static String ERROR_NO_RESUlTS_FOUND ="No results were found!";
	private static String ERROR_IO_TASK   	   ="The task could not be changed!";
	private static String ERROR_NO_DESC   	   ="You must have a description for your task!";
	private static String ERROR_CANNOT_UNDO      ="No more changes to undo.";
	private static String ERROR_CANNOT_REDO      ="No more changes to redo.";
	private static String ERROR_START_BEFORE_END ="You have entered an end time that is before start time!";
	private static String ERROR_DATEFORMAT       ="You have entered an invalid date and time. Note that we follow American date format mm/dd/yy.";
	private static String ERROR_TRIGGER_ERROR    ="ERROR! The trigger shortcut has been interrupted and aborted.";
	private static String ERROR_MALFORMED_TASK   ="ERROR! Corrupted task region. Task %d has been discarded.";
	private static String ERROR_MALFORMED_FILE   ="ERROR! Corrupted file region. Rest of file cannot be read.";
	private static String ERROR_MALFORMED_KEY    ="ERROR! File does not match expected format. Restart program with a new file location.";
	private static String ERROR_FILE_IO          ="ERROR! Cannot read from specified file location.";
	private static String ERROR_HTML_TEMPLATE    ="ERROR! Cannot read html template.";
	
	// Define help messages here
	private static String HELP_TITLE             ="**********************************************************************Help menu for TaskBuddy!*****************************************************************";
	private static String HELP_HEADING           ="Please follow the following command format:";
	private static String HELP_SUBTITLE          ="[COMMAND]   [FORMAT]                                                                                                                                    ";
	private static String HELP_PATH              ="  PATH          : path [absolute filepath]";
	private static String HELP_FILEOPEN          ="  FILEOPEN  : fileopen";
	private static String HELP_FILESAVE          ="  FILESAVE   : filesave";
	private static String HELP_ADD_TASK          ="  ADD            : add do \"[description]\" on [startDate/endDate] from [startTime] to [endTime] by [deadlineDate] [deadlineTime] at \"[venue]\"              ";
	private static String HELP_DISPLAY           ="  DISPLAY    : display                                                                                                                                   ";
	private static String HELP_EDIT_TASK         ="  EDIT           : edit [task-id] do \"[description]\" on [startDate/endDate] from [startTime] to [endTime] by [deadlineDate] [deadlineTime] at \"[venue]\"      ";
	private static String HELP_UNDO              ="  UNDO        : undo                                                                                                                                      ";
	private static String HELP_REDO              ="  REDO        : redo                                                                                                                                      ";
	private static String HELP_DONE              ="  DONE        : done [task-id]                                                                                                                            ";
	private static String HELP_UNDONE            ="  UNDONE   : undone [task-id]                                                                                                                          ";	
	private static String HELP_DELETE_TASK       ="  DELETE     : delete [task-id]                                                                                                                          ";
	private static String HELP_HELP              ="  HELP         : help                                                                                                                                      ";
	private static String HELP_EXIT              ="  EXIT          : exit                                                                                                                                      ";
	
	private static ArrayList<Task> taskList          = new ArrayList<Task>(50);
	private static SimpleDateFormat df               = new SimpleDateFormat("M/dd/yyyy HHmm"); 
	private static Context context 					 = Context.getInstance();
	
	@BeforeClass
	public static void setUp() {
		deleteFile("./test/data/test10.json");
		String[] path = {"./test/data/test10.json"};
		TaskHandler.init(path);
	}

	private static void deleteFile(String path) {
		File testFile = new File(path);
	    if (testFile.exists()) {
	    	testFile.delete();     
	    }
	}
	
	@SuppressWarnings("unchecked")
	@Test
	public void testExecuteCommand() {
		String userInput 					= null;
		
		HashMap<String,Object> expected  	= null;
		HashMap<String,Object> actual  		= null;
		ArrayList<String> errorList			= new ArrayList<String>();
		ArrayList<String> successList	  	= new ArrayList<String>();
		ArrayList<String> warningList  		= new ArrayList<String>();
		ArrayList<String> helpList			= new ArrayList<String>();
		ArrayList<String> paramList			= new ArrayList<String>();
		ArrayList<Task>   taskList 			= new ArrayList<Task>();
		
		Task   task1      					= null;
		Task   task2      					= null;
		Task   task3      					= null;
		Task   task4      					= null;
		Task   task5     					= null;
		Task   task6     					= null;
		
		Date   startTime 					= null;
		Date   endTime   					= null;
		Date   deadline  					= null;
		
		// Test display
		userInput = "display";
		
		errorList = new ArrayList<String>();
		errorList.add(ERROR_EMPTY_TASKLIST);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		
		// Test for misspelling
		userInput = "dsplay";
		
		errorList = new ArrayList<String>();
		errorList.add(ERROR_INVALID_COMMAND);
		
		helpList = new ArrayList<String>();
		helpList.add(HELP_ADD_TASK);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		
		// Test for add floating task
		userInput = "add do \"sth1\"";
		task1      = new Task(1, "sth1",null, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList.add(task1);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		/*
		// Test for add event task
		userInput = "add on 12/10/15 from 1200 to 1240 do \"sth2\"";
		try {
			startTime = df.parse("12/10/15 1200");
			endTime   = df.parse("12/10/15 1240");
			
		} catch (ParseException e) {
			e.printStackTrace();
		}
		task2     = new Task(2, "sth2", startTime, endTime, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList = new ArrayList<Task>();
		taskList.add(task2);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(((ArrayList<Task>)expected.get(taskList)).get(1), ((ArrayList<Task>)actual.get(taskList)).get(1));
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		
		// Test for add event task with different start and end dates
		userInput = "add do \"sth3\" from 12/10/15 1200 to 14/10/15 1340";
		try {
			startTime = df.parse("12/10/15 1200");
			endTime   = df.parse("14/10/15 1340");
			
		} catch (ParseException e) {
			e.printStackTrace();
		}
		task3     = new Task(3, "sth3", startTime, endTime, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList = new ArrayList<Task>();
		taskList.add(task3);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		// Test for add event task with unspecified end time
		userInput = "add do \"sth4\" on 12/10/15 from 1200";
		try {
			startTime = df.parse("12/10/15 1200");
			endTime   = df.parse("12/10/15 1300");
			
		} catch (ParseException e) {
			e.printStackTrace();
		}
		task4     = new Task(4, "sth4", startTime, endTime, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList = new ArrayList<Task>();
		taskList.add(task4);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		// Test for add event task with unspecified start time
		userInput = "add do \"sth5\" on 12/10/15 to 1240";
		try {
			startTime = df.parse("12/10/15 1100");
			endTime   = df.parse("12/10/15 1240");
			
		} catch (ParseException e) {
			e.printStackTrace();
		}
		task5     = new Task(5, "sth5", startTime, endTime, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList = new ArrayList<Task>();
		taskList.add(task5);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		// Test for add deadline task
		userInput = "add do \"sth6\" by 12/10/15 2359";
		try {
			deadline = df.parse("12/10/15 2359");
			
		} catch (ParseException e) {
			e.printStackTrace();
		}
		task6     = new Task(6, "sth6", startTime, endTime, null);
		
		successList = new ArrayList<String>();
		successList.add(MESSAGE_ADD_TASK);
		taskList = new ArrayList<Task>();
		taskList.add(task6);
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		*/
		
		
		// Test for edit desc only
		userInput = "edit 1 do \"nothing-5\"";
		
		task1      = new Task(1, "nothing-5",null, null);
		taskList.add(task1);
		successList = new ArrayList<String>();
		successList.add(String.format(MESSAGE_EDIT_TASK, 1));
		
		expected = buildExpectedHashmap(successList,warningList,helpList,paramList,errorList,taskList);
		
		TaskHandler.executeCommand(userInput);
		actual = stripJson(context.getDataModel());
		assertEquals(expected, actual);
		context.clearAllMessages();
		clearArrayLists(successList,warningList,helpList,paramList,errorList,taskList);
		
		/*
		// Test for edit floating to event (set startDate, startTime, endDate and endTime
		userInput = "edit 2 on 12/10/15 from 1200 to 1400";

		task      = new Task(3, "sth4", startTime, endTime, null);
		expected  = task.toString() + "\n" + MESSAGE_ADD_TASK;
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit floating task startDate only
		userInput = "edit 5 from 15/10/15";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit floating task startDate and startTime
		userInput = "edit 5 from 15/10/15 2115";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task startDate, startTime and endTime
		userInput = "edit 5 on 25/10/15 from 1130 to 1409";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task endDate and endTime 
		userInput = "edit 5 to 23/10/15 2358";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task endDate only
		userInput = "edit 5 to 24/12/15";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task startDate and endDate only
		userInput = "edit 5 on 25/12/15";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);

		// Test for edit task startDate and startTime only
		userInput = "edit 5 on 25/09/15 from 1000";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task endDate and endTime only
		userInput = "edit 5 on 25/10/15 to 0030";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for edit task venue
		userInput = "edit 5 at \"do from on to at by\"";
		expected  = MESSAGE_EDIT_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		
		// Test for delete task
		userInput = "delete 2";
		expected  = MESSAGE_DELETE_TASK;
		TaskHandler.executeCommand(userInput);
		assertEquals(expected, actual);
		*/
	}
	
	private void clearArrayLists(ArrayList<String> successList, ArrayList<String> warningList,
			ArrayList<String> helpList, ArrayList<String> paramList, ArrayList<String> errorList,
			ArrayList<Task> taskList) {
		errorList.clear();
		successList.clear();
		warningList.clear();
		helpList.clear();
		paramList.clear();
		taskList.clear();
	}

	private HashMap<String, Object> stripJson(HashMap<String, Object> dataModel) {
		dataModel.remove("jsonData");
		dataModel.remove("default_date");
		dataModel.remove("view_messages");
		return dataModel;
	}

	private HashMap<String, Object> buildExpectedHashmap(ArrayList<String> success_messages, ArrayList<String> warning_messages, 
			ArrayList<String> help_messages, ArrayList<String> param_messages, ArrayList<String> error_messages, 
			ArrayList<Task> taskList) {	
		HashMap<String, Object> expected = new HashMap<String, Object> ();
		
		expected.put("success_messages", success_messages);
		expected.put("warning_messages", warning_messages);
		expected.put("help_messages", help_messages);
		expected.put("param_messages", param_messages);
		expected.put("error_messages", error_messages);
		expected.put("taskList", taskList);
		
		return expected;
		
	}

	@AfterClass
	public static void tearDown(){
		taskList.clear();
		File file1 = new File("./test/data/test10.json");
		file1.delete();
		
	}
}
```
